(***
  (
    (features (Polymorphic_types Refinement_types Dependent_arrows Modules Mu_types Parametric_types First_class_types Variants Records Recursive_functions Higher_order_functions Subtyping OOP_style Return_error Usage_error Other))
    (reasons (Polymorphic_types Refinement_types Dependent_arrows Modules Mu_types Parametric_types First_class_types Variants Records Recursive_functions Higher_order_functions Subtyping OOP_style Return_error Usage_error Other))
    (speed <Fast or Slow>)
    (typing <Well_typed or Ill_typed>)
  )
*)
(*** (
  (features (Variants Recursive_functions Mu_types Refinement_types Records Match))
  (reasons (Mu_types Refinement_types))
  (speed Fast)
  (typing Ill_typed)
) *)

let max x1 x2 = 
  if x1 > x2 then x1 else x2

let abs n = 
  if n > 0 then n else (0-1) * n

let rec get_height t = 
  match t with
  | `Node node -> max (get_height node.left) (get_height node.right) + 1
  | `Leaf leaf -> 1
  end

let rec is_balanced t = 
  match t with
  | `Node node ->
    is_balanced node.left
    && is_balanced node.right
    && abs (get_height node.left - get_height node.right) <= 1
  | `Leaf leaf -> true
  end

let tree_type = Mu t.
  | `Node of { left : t; right : t }
  | `Leaf of { leaf : int }
  

let x : { tree_type | is_balanced } = 
  `Node
  { left = 
    `Node { left = 
            `Node { left = 
                  `Node { left = `Leaf {leaf = 0}
                        ; right = `Leaf {leaf = 0}
                        }
                  ; right = `Leaf {leaf = 0}
                  }
          ; right = `Leaf {leaf = 0}
          }
  ; right = `Leaf { leaf = 0 }
  }
