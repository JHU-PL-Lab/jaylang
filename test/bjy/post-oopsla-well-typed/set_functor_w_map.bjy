(* Here we extend set_functor_full.bjy to also include a map on the input module.  This is a bit more complex since there are two list types in the general case and it seems like we need to hoist all of that out.  This is a bit gross so there should probably be some sugar for this kind of stuff.  Other cases where we need a special type in the list module for example are zip/unzip, also concat.  Concat would also be desirable on sets. *)
let ( F : 
    (S : {: tf : type -> type 
    ; a : type
    ; b : type
    ; ta : singlet (tf a)
    ; tb : singlet (tf b)
    ; empty : unit -> ta
    ; add   : a -> ta -> ta
    ; map : ta -> (a -> b) -> tb
    :})
    ->
    { tf : type -> type
    ; a : type
    ; b : type
    ; ta : singlet (S.ta)
    ; tb : singlet (S.tb)
    ; empty   : unit -> S.ta
    ; add     : S.a -> S.ta -> S.ta
    ; map : S.ta -> (S.a -> S.b) -> S.tb
    ; of_list : (list S.a) -> S.ta
    })
  =
  fun S ->
    { tf = S.tf
    ; a = S.a
    ; b = S.b
    ; ta = S.ta
    ; tb = S.tb
    ; empty = S.empty
    ; add = S.add
    ; map = S.map
    ; of_list =
      fun ls ->
        let rec loop acc ls =
          match ls with
         | [] -> acc
          | hd :: tl -> loop (S.add hd acc) tl
          end
        in 
        loop (S.empty {}) ls
    }

let (M : (a : type) -> (b : type) -> 
  {: tf : type -> type 
  ; a : type
  ; b : type
  ; ta : singlet (tf a)
  ; tb : singlet (tf b)
  ; empty : unit -> ta
  ; add   : a -> ta -> ta
  ; map : ta -> (a -> b) -> tb
  :})
 = fun a b ->
    let tf = fun a -> list a in
    let ta = tf a in
    let tb = tf b in
    { tf = tf
    ; a = a
    ; b = b
    ; ta = ta
    ; tb = tb
    ; empty = fun mt -> [] 
    ; add   = fun a ls -> a :: ls 
    ; map = 
      let rec mapper ls f =
        match ls with
        | [] -> []
        | hd :: tl -> (f hd) :: (mapper tl f)
        end
      in 
      mapper }

let MM = F (M int int) (* now need to pass in both a and b types *)

let (r : MM.ta) = MM.add 1 (MM.add 2 (MM.empty {}))

let (r2 : (MM.tf) int) = MM.of_list ([1;2;3;4;5;6;7])

let (rmapp : (MM.tf) int) = MM.map r2 (fun x -> x + 1)

let (x : MM.a) = 0

let (list_is_visible : MM.ta) = [2]

(* The above fixes the map type too early perhaps.  In general it might be good to program more like this, instantiate functor each time it is used to allow maps etc over arbitrary types.  This is more like the way List.map etc works now in OCaml: *)
let (r3 : ((F (M int int)).tf) int) = (F (M int int)).map r2 (fun x -> x + 1)