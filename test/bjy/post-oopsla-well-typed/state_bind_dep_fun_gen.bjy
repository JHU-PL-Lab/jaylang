
(* In this program; we have a function to recursively generate a type (int -> int -> ... -> int) *)
(* depending on the size of the input. *)
(* Not only that; but we use a state monad to do it. *)

let State_monad =
  { m = fun a -> fun s ->
      s -> { res : a ; new_state : s }
  ; bind =
      let impl x f =
        fun s ->
          let xs = x s in
          f xs.res xs.new_state
      in
      impl
  ; return = 
      let impl x = 
        fun s -> 
          { res = x ; new_state = s }
      in
      impl
  ; modify =
      let impl f =
        fun s ->
          let fs = f s in
          { res = fs ; new_state = fs }
      in
      impl
  ; read = fun s -> { res = s ; new_state = s }
  ; run =
      let impl x s =
        (x s).res
      in
      impl
  }

(* We don't that easily have a forall type, so I do this little trick *)
let confirm_type_of_state_monad (type a b s) (dummy : unit) :
  (let m = State_monad.m in 
  { read : m s s
  ; bind : m a s -> (a -> m b s) -> m b s
  ; return : a -> m a s
  ; modify : (s -> s) -> m s s
  ; run : m a s -> s -> a
  })
  =
  State_monad

let t n = 
  int -> (
    let rec loop acc_m =
      State_monad.bind (State_monad.modify (fun i -> i - 1)) (fun i ->
        if i <= 1 
        then acc_m
        else
          State_monad.bind acc_m (fun acc ->
            loop (State_monad.return (int -> acc))
          )
      )
    in
    State_monad.run (loop (State_monad.return int)) n
    (* EXAMPLE ERROR: don't use run. Just apply state by self (and thereby forget to project the result from the record) *)
    (* But such an error is instant to catch just in the generation of a value with type t *)
  )

let main (n <- int) (f : t n) : (int -> int) =
  let rec loop i = 
    if i <= 0
    then f
    else (loop (i - 1)) i
  in
  loop (n - 2)
