(***
  (
    (features (Polymorphic_types Refinement_types Dependent_arrows Mu_types Parametric_types First_class_types Variants Records Recursive_functions))
    (speed Slow)
    (typing Well_typed)
  )
*)

(* This test is slow because there are so many types. It is way faster with parallelism on, which is a good thing! *)

(* These are the possible forms of the type parameter for t *)
let ty = Mu t.
  | `TOne of unit
  | `TSucc of t

(* a "GADT" *)
let rec t (a : ty) : type =
  | `One of
    match a with
    | `TOne _ -> unit
    | `TSucc _ -> assume false (* not a valid type parameter for the `One constructor *)
    end
  | `Succ of
    match a with
    | `TOne _ -> assume false (* not a valid type parameter for the `Succ constructor *)
    | `TSucc a -> t a
    end

(* concrete, constant example *)
let three_type_param = `TSucc (`TSucc (`TOne {}))
let three_type = t three_type_param
let three : three_type = `Succ (`Succ (`One {}))

let rec to_int (a <- ty) (x : t a) : int =
  match x with
  | `One _ -> 1
  | `Succ y ->
    match a with
    | `TSucc b -> 1 + to_int b y
    end
  end

(* example usage *)
let _ : { i : int | i == 3 } = to_int three_type_param three

(* of_int with untyped return *)
let rec of_int (i : { i : int | i > 0 }) : top =
  if i == 1 then 
    `One {}
  else
    `Succ (of_int (i - 1))

(* return type as value from result, and also have a predicate to check that it's the inverse of to_int *)
let rec of_int (i <- { i : int | i > 0 }) : { r : {: a : ty ; v : t a :} | to_int r.a r.v == i } =
  if i == 1 then 
    { a = `TOne {} ; v = `One {} }
  else
    let r = of_int (i - 1) in
    { a = `TSucc r.a ; v = `Succ r.v }
