(***
  (
    (features (Polymorphic_types Dependent_types Mu_types Parametric_types First_class_types Deterministic_functions Variants Records Recursive_functions Higher_order_functions)) ; not really mu types. Recursive type functions, though
    (speed Slow) ; single digit seconds when splaying depth is 1
    (typing Exhausted) ; possible only with all the flags below
    (flags "-s -p -w no -d 100") ; splaying, parallel, no wrapping, and bigger depth
  )
*)

let rec ty n =
  if n <= 0
  then type
  else type --> ty (n - 1)

let ty1 = ty 1

let t : ty1 --> type --> type = fun f a -> mu t.
  | `Return of a
  | `Bind of sig 
      val b : type 
      val intermediate : f b
      val cont : b -> t
    end

let r_with_cont r k = struct
  let b = r.b 
  let intermediate = r.intermediate 
  let cont = k
end

let perform 
  : (a : type) -> (f : ty1) -> f a -> t f a
  = fun a f fa ->
  `Bind struct
    let b = a 
    let intermediate = fa 
    let cont = fun a -> `Return a
   end

let handler
  : ty1 --> type
  = fun f ->
    (a : type) -> (b : type) -> (a -> b) -> f a -> b

let rec run (type a) (dependent f : ty1) (h : handler f) (x : t f a) : a =
  match x with
  | `Return a -> a
  | `Bind r -> h r.b a (fun x -> run a f h (r.cont x)) r.intermediate
  end

(*
  These next two are the really slow ones.
*)

let rec map (type a b) (dep f : ty1) (tfa : t f a) (h : a -> b) : t f b =
  match tfa with
  | `Return a -> `Return (h a)
  | `Bind r -> `Bind (r_with_cont r (fun x -> map a b f (r.cont x) h))
  end

let rec bind (type a b) (dep f : ty1) (tfa : t f a) (h : a -> t f b) : t f b =
  match tfa with
  | `Return a -> h a
  | `Bind r -> `Bind (r_with_cont r (fun x -> bind a b f (r.cont x) h))
  end
