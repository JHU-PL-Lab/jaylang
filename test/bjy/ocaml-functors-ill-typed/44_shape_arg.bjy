
(*
module Shape_arg = struct
  module M1 (Arg1 : sig end) = struct
    module type S1 = sig
      type t
    end
  end

  module type S2 = sig
    module Make (Arg2 : sig end) : M1(Arg2).S1
  end

  module M2 : S2 = struct
    module Make (Arg3 : sig end) = struct
      type t = T
    end
  end

  module M3 (Arg4 : sig end) = struct
    module type S3 = sig
      type t = M2.Make(Arg4).t
    end
  end

  module M4 (Arg5 : sig end) : M3(Arg5).S3 = struct
    module M5 = M2.Make (Arg5)

    type t = M5.t
  end
end
*)

(* This test is originally well-typed. We add an arbitrary error by leaving off some detail in the M3 functor,
  which OCaml is able to infer. Bluejay, without type inference, needs some annotation or none at all. This
  in-between, which we write below, is not good. *)

let Shape_arg = struct
  let M1 (Arg1 : sig end) : sig val S1 : singlet (sig val t : type end) end = struct
    let S1 = sig
      val t : type
    end
  end

  let S2 = sig
    val Make : (Arg2 : sig end) -> (M1(Arg2)).S1
  end

  let M2 : S2 = struct
    let Make Arg3 = struct
      let t = `T of unit
    end
  end

  (* This commented code is the original type *)
  (* let M3 (dep Arg4 : sig end) : sig val S3 : singlet (sig val t : singlet (M2.Make(Arg4)).t end) end = struct *)

  (* ERROR: S3 not detailed enough *)
  let M3 (dep Arg4 : sig end) : sig val S3 : singlet (sig end) end = struct
    let S3 = sig
      val t : singlet ((M2.Make(Arg4)).t)
    end
  end

  let M4 (dep Arg5 : sig end) : (M3(Arg5)).S3 = struct
    let M5 = M2.Make (Arg5)

    let t = M5.t
  end
end
