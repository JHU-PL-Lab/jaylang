# This used to be the minimal example for a failing program. It now works just fine.
# This was challenging because after the first run, it would need to solve for second_cond == false,
#   so x < first_branch, but it only knew what first_branch was on the true side. So it might give
#   an input that hit the false side and failed to hit the target, but with more information from a
#   second run, it would successfully hit the target. 

# note that concolic gives inputs in [-10, 10] on first run.

# EXPECTED BRANCH INFORMATION
# first_branch: True=Hit; False=Hit
# second_branch: True=Hit; False=Hit

x = input;
large = 100;

first_cond = x < large; # always true on first run
first_branch = first_cond ? (
  first_branch_true_return = -11
) : (
  first_branch_false_return = 100
);

one = 1;
x_plus_one = x + one;
second_cond = first_branch < x_plus_one; # always true on first run

second_branch = second_cond ? (
  result_true = 42
) : (
  result_false = 84
)
