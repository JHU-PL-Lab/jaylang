# minimal failing example
# all branches should be solvable
# cannot solve for second_cond = false
# it solves just fine without the branch and with `first_branch = -10;` instead, all else the same.
# it also solves just fine when x is not used in any computation before `second_cond`, and only a computation using `<=` seems okay.
# Now I'm seeing that just having zero and one statements makes it fail. But neither individually fails it.


# note that concolic gives inputs in [-10, 10] on first run.

x = input;
large = 100;

first_cond = x < large; # always true on first run
first_branch = first_cond ? (
  first_branch_true_return = -11
) : (
  first_branch_false_return = 100
);

# zero = 0;
# x_plus_zero = x + zero; # if this is uncommented, it fails. If commented, it works
# one = 1;
# ^ note I don't even have to USE this anywhere. Old concolic versions fail even with this commented.
second_cond = first_branch < x;

second_branch = second_cond ? (
  result_true = 42
) : (
  result_false = 84
)
