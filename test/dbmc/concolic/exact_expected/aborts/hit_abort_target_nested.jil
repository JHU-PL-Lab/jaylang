# goal is to have three branches
# 1. arbitrary branches that will be targeted last
# 2. branch with an abort that gets targeted and hit
# 3. branch that gets handled before targeting abort
#
# This way, we test how aborts are handled in the midst of other solves.
# Further, this is nested within a parent branch to check that deeper logic works.

x = input;

neg_five = -5;

outer_cond = neg_five < x;

outer_branch = outer_cond ? (
  large_int = 100;

  # concolic evaluator always gives input < 100 on first run
  default_true_cond = x < large_int;

  default_true_branch = default_true_cond ? (
    # always hit on first run through the true side of outer_branch
    default_true_branch_true_ret = true
  ) : (
    default_true_branch_false_ret = false
  );

  # always true on first run, so abort is not hit on first run
  abort_on_false_side_cond = default_true_branch;

  abort_on_false_side_branch = abort_on_false_side_cond ? (
    # always hit on first run
    abort_on_false_side_true_ret = 0
  ) : (
    some_stuff = 1;
    abort_on_false_side_false_ret = abort;
    other_stuff = 2;
    large_stuff = 100000
  );

  one = 1;
  x_plus_one = x + one;

  # This is true when initial input is x where 0 <= x < 100
  final_branch_cond = abort_on_false_side_branch < x_plus_one;

  final_branch = final_branch_cond ? (
    result = 42
  ) : (
    other_result = 84
  )
) : (
  other_other_result = 126
)
