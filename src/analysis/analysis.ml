(**
  This module gives an implementation of the DDPA analysis.  It is parametric
  in the choice of context stack.
*)

open Batteries;;

open Analysis_context_stack;;
open Ast;;
open Ast_pp;;
open Ddpa_graph;;
open Nondeterminism;;
open Pds_reachability_types_stack;;
open String_utils;;

let logger = Logger_utils.make_logger "Analysis";;
let lazy_logger = Logger_utils.make_lazy_logger "Analysis";;

exception Non_record_projection of string;;

module type Analysis_sig =
sig
  (** The type of the DDPA analysis generated by the module. *)
  type ddpa_analysis
  
  (** The context stack module for this analysis. *)
  module C : Context_stack;;
  
  (** The initial, unclosed analysis derived from an expression. *)
  val create_initial_analysis :
    ?logging_prefix:string option -> expr -> ddpa_analysis
  
  (** Pretty-prints a DDPA structure. *)
  val pp_ddpa : ddpa_analysis -> string

  (** Get size of DDPA and underlying PDS. *)
  val get_size : ddpa_analysis -> int * int * int * int * int
  
  (** Performs a series of closure steps on an analysis.  This is not guaranteed
      to complete closure; however, it will make progress as long as the
      argument is not fully closed. *)
  val perform_closure_steps : ddpa_analysis -> ddpa_analysis
  
  (** Determines if an analysis is fully closed. *)
  val is_fully_closed : ddpa_analysis -> bool
  
  (** Fully closes an analysis. *)
  val perform_full_closure : ddpa_analysis -> ddpa_analysis
  
  (** Determines the values at a given position of the provided variable in the
      given analysis.  This is an approximation -- false positives may arise --
      but it is guaranteed to be conservative if the analysis is fully closed.
      The returned analysis contains a cache structure to accelerate answering
      of this question in the future. *)
  val values_of_variable :
    var -> annotated_clause -> ddpa_analysis ->
      Abs_filtered_value_set.t * ddpa_analysis

  val contextual_values_of_variable :
    var -> annotated_clause -> C.t -> ddpa_analysis ->
      Abs_filtered_value_set.t * ddpa_analysis
    
  (** Sets the logging level for the PDS reachability analysis used by this
      module. *)
  val set_pdr_logger_level :
    Pds_reachability_logger_utils.pds_reachability_logger_level -> unit
    
  (** Gets the logging level for the PDS reachability analysis used by this
      module. *)
  val get_pdr_logger_level :
    unit -> Pds_reachability_logger_utils.pds_reachability_logger_level

end;;

(**
  A functor which constructs a DDPA analysis module.
*)
module Make(C : Context_stack)
  : Analysis_sig with module C = C =
struct
  module C = C;;

  let rv body =
    match body with
    | [] -> raise @@
              Utils.Invariant_failure "empty function body provided to rv"
    | _ -> let Abs_clause(x,_) = List.last body in x
  ;;

  (* FIXME: the following restriction isn't in the spec, but maybe it should be... just here to test things for now *)
  (* The `pattern_set' passed into this function must not contain the empty record pattern. Use the following guard to test:
      (* FIXME: the following isn't in the spec, but maybe it should be... just here to test things for now *)
      [% guard (not @@
                    Pattern_set.mem (Record_pattern Ident_map.empty) pattern_set) ];
  *)
  let negative_pattern_set_selection record_type pattern_set =
    let (Record_value m) = record_type in
    let record_labels = Ident_set.of_enum @@ Ident_map.keys m in
    let relevant_patterns = pattern_set
      |> Pattern_set.enum
      |> Enum.filter
        (fun pattern ->
           match pattern with
           | Record_pattern m' ->
            Ident_set.subset (Ident_set.of_enum @@ Ident_map.keys m')
              record_labels
           | _ -> false)
    in
    (* This function selects a single label from a given pattern and constructs
       a pattern from it. *)
    let pick_pattern pattern =
      match pattern with
      | Record_pattern m' ->
        let open Nondeterminism_monad in
        let%bind (k,v) = pick_enum @@ Ident_map.enum m' in
        return @@ Record_pattern(Ident_map.singleton k v)
      | _ -> raise @@ Utils.Invariant_failure ("The non-record pattern `" ^ pp_pattern pattern ^ "' ended up on `analysis.ml:negative_pattern_set_selection:pick_pattern'.")
    in
    let open Nondeterminism_monad in
    let%bind selected_patterns = 
      Nondeterminism_monad.mapM pick_pattern relevant_patterns
    in
    return @@ Pattern_set.of_enum selected_patterns
  ;;

  let pattern_projection pattern label =
    match pattern with
    | Record_pattern m ->
      begin
        try
          Some (Ident_map.find label m)
        with
        | Not_found -> None
      end
    | _ -> raise @@ Non_record_projection ("Tried to project out of a non-record pattern `" ^ pp_pattern pattern ^ "' in `analysis.ml:pattern_projection'.")
  ;;

  let pattern_set_projection set label =
    set
    |> Pattern_set.enum
    |> Enum.map (flip pattern_projection label)
    |> Enum.filter_map identity
    |> Pattern_set.of_enum
  ;;

  let is_record_pattern_set set =
    set
    |> Pattern_set.enum
    |> Enum.for_all
      (
        fun pattern ->
          match pattern with
          | Record_pattern _ -> true
          | _ -> false
      )
  ;;

  let labels_in_record (Record_value m) =
    Ident_set.of_enum @@ Ident_map.keys m
  ;;

  let labels_in_pattern pattern =
    match pattern with
    | Record_pattern m ->
      Ident_set.of_enum @@ Ident_map.keys m
    | _ -> raise @@ Non_record_projection ("Tried to enumerate labels out of a non-record pattern `" ^ pp_pattern pattern ^ "' in `analysis.ml:labels_in_pattern'.")
  ;;

  let labels_in_pattern_set set =
    set
    |> Pattern_set.enum
    |> Enum.map labels_in_pattern
    |> Enum.fold Ident_set.union Ident_set.empty
  ;;

  let is_immediate acl =
    match acl with
    | Unannotated_clause(abs_clause) -> is_abstract_clause_immediate abs_clause
    | Enter_clause _
    | Exit_clause _ -> true
    | Start_clause
    | End_clause -> false
  ;;
  
  (** This module is meant to verify that the system never attempts to create
   *  a capture size larger than a fixed maximum (here, 4).  This property is
   *  necessary to argue that the analysis is decidable.
   *)
  module Bounded_capture_size :
  sig
    type bounded_capture_size;;
    val compare_bounded_capture_size :
      bounded_capture_size -> bounded_capture_size -> int
    (*val equal_bounded_capture_size :
      bounded_capture_size -> bounded_capture_size -> bool*)
    val make_bounded_capture_size : int -> bounded_capture_size
    val int_of_bounded_capture_size : bounded_capture_size -> int
  end =
  struct
    type bounded_capture_size =
      | Bounded_capture_size of int
      [@@deriving ord]
    ;;
    let max_capture_size = 5;;
    let make_bounded_capture_size n =
      if n >= 1 && n <= max_capture_size
      then Bounded_capture_size(n)
      else raise @@ Utils.Invariant_failure(
        Printf.sprintf "Invalid size %d provided for bounded capture" n);;
    let int_of_bounded_capture_size (Bounded_capture_size(n)) = n;;
  end;;
  open Bounded_capture_size;;

  type pds_continuation =
    | Bottom_of_stack
    (** The bottom of stack element is necessary as a sentinel. It's pushed as
        the initial element on the continuation stack so we don't need to check
        for empty continuation stacks. *)
    | Lookup_var of var * Pattern_set.t * Pattern_set.t
    | Project of ident * Pattern_set.t * Pattern_set.t
    | Jump of annotated_clause * C.t
    | Deref of Pattern_set.t * Pattern_set.t
    | Capture of bounded_capture_size
    | Continuation_value of abs_filtered_value
    | Real_flow_huh
    | Alias_huh
    | Side_effect_search_start
    | Side_effect_search_escape of var
    | Side_effect_lookup_var of
        var * Pattern_set.t * Pattern_set.t * annotated_clause * C.t
    | Binary_operation
    | Unary_operation
    [@@deriving ord]
  ;;

  module Pds_continuation_ord =
  struct
    type t = pds_continuation
    let compare = compare_pds_continuation
  end;;

  let pp_pds_continuation = function
    | Bottom_of_stack ->
      "Bottom_of_stack"
    | Lookup_var(x,patsp,patsn) ->
      Printf.sprintf "%s(%s/%s)"
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Project(i,patsp,patsn) ->
      Printf.sprintf ".%s(%s/%s)"
        (pp_ident i) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Jump(acl,ctx) ->
      Printf.sprintf "Jump(%s,%s)" (pp_annotated_clause acl) (C.pp ctx)
    | Deref(patsp,patsn) ->
      Printf.sprintf "!(%s,%s)" (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Capture(size) ->
      Printf.sprintf "Capture(%d)" @@ int_of_bounded_capture_size size
    | Continuation_value(fv) -> pp_abs_filtered_value fv
    | Real_flow_huh -> "RealFlow?"
    | Alias_huh -> "Alias?"
    | Side_effect_search_start -> "Side_effect_search_start"
    | Side_effect_search_escape x ->
      Printf.sprintf "Side_effect_search_escape(%s)" (pp_var x)
    | Side_effect_lookup_var(x,patsp,patsn,acl,ctx) ->
      Printf.sprintf "Side_effect_lookup_var(%s,%s,%s,%s,%s)"
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
        (pp_annotated_clause acl) (C.pp ctx)
    | Binary_operation -> "Binary_operation"
    | Unary_operation -> "Unary_operation"
  ;;

  let ppa_pds_continuation = function
    | Bottom_of_stack -> "Bot"
    | Lookup_var(x,patsp,patsn) ->
      if Pattern_set.is_empty patsp && Pattern_set.is_empty patsn
      then pp_var x
      else Printf.sprintf "%s(%s/%s)"
              (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Project(i,patsp,patsn) ->
      if Pattern_set.is_empty patsp && Pattern_set.is_empty patsn
      then Printf.sprintf ".%s" (pp_ident i)
      else Printf.sprintf ".%s(%s/%s)"
              (pp_ident i) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Jump(acl,ctx) ->
      Printf.sprintf "Jump(%s,%s)"
        (ppa_annotated_clause acl) (C.ppa ctx)
    | Deref(patsp,patsn) ->
      Printf.sprintf "!(%s,%s)" (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Capture(size) ->
      Printf.sprintf "Capture(%d)" @@ int_of_bounded_capture_size size      
    | Continuation_value(fv) -> pp_abs_filtered_value fv
    | Real_flow_huh -> "RealFlow?"
    | Alias_huh -> "Alias?"
    | Side_effect_search_start -> "SEStart"
    | Side_effect_search_escape x ->
      Printf.sprintf "SEEsc(%s)" (pp_var x)
    | Side_effect_lookup_var(x,patsp,patsn,acl,ctx) ->
      Printf.sprintf "SEVar(%s,%s,%s,%s,%s)"
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
        (pp_annotated_clause acl) (C.pp ctx)
    | Binary_operation -> "BinOp"
    | Unary_operation -> "UnOp"
  ;;

  type pds_state =
    | Program_point_state of annotated_clause * C.t
      (** A state in the PDS representing a specific program point and
          context. *)
    | Result_state of abs_filtered_value
      (** A state in the PDS representing a value result. *)
    [@@deriving ord]
  ;;

  let pp_pds_state state =
    match state with
    | Program_point_state(acl,ctx) ->
      Printf.sprintf "(%s @ %s)" (pp_annotated_clause acl) (C.pp ctx)
    | Result_state(Abs_filtered_value(v,patsp,patsn)) ->
      Printf.sprintf "(%s(%s/%s))"
        (pp_abstract_value v) (pp_pattern_set patsp) (pp_pattern_set patsn)
  ;;

  let ppa_pds_state state =
    match state with
    | Program_point_state(acl,ctx) ->
      Printf.sprintf "(%s @ %s)" (ppa_annotated_clause acl) (C.ppa ctx)
    | Result_state(Abs_filtered_value(v,patsp,patsn)) ->
      Printf.sprintf "(%s(%s/%s))"
        (pp_abstract_value v) (pp_pattern_set patsp) (pp_pattern_set patsn)
  ;;

  module Program_point_state_ord =
  struct
    type t = pds_state
    let compare = compare_pds_state
  end;;

  module Ddpa_pds_reachability_basis = 
  struct
    type state = pds_state
    type stack_element = pds_continuation
    module State_ord = Program_point_state_ord
    module Stack_element_ord = Pds_continuation_ord
    let pp_state = pp_pds_state
    let pp_stack_element = pp_pds_continuation
    let ppa_state = ppa_pds_state
    let ppa_stack_element = ppa_pds_continuation
  end
  
  type pds_targeted_dynamic_pop_action =
    | Value_drop
      (** An action to drop values from the top of the stack.  This is necessary
          for actions such as non-local lookup which perform a subordinate
          lookup but do not act upon the resulting value. *)
    | Value_discovery_2_of_2
      (** The second step of value discovery, which confirms that the special
          "bottom" stack element is next on the stack.  This step pops that
          element so that the targeted value state can be accepted (by empty
          stack).  Note that the first step of value discovery is untargeted. *)
    | Variable_aliasing of var * var
      (** Represents variable aliasing, as in "x = y".  The first variable
          is the one being declared; the second variable is the one being
          used.  This pop action is used for every rule which performs basic
          x-to-y aliasing regardless of whether the clause in question is
          annotated. *)
    | Stateless_nonmatching_clause_skip_1_of_2 of var
      (** Represents the first step of skipping a non-matching clause while
          stateless.  If we are searching for x, we may skip over any clause of
          the form x'' = b (even if b is non-immediate) as long as we are not
          trying to dereference x''.  The first step of this process captures
          the variable which we should *not* match.  The second step carries
          the variable continuation and confirms the absence of a dereference
          continuation. *)
    | Stateless_nonmatching_clause_skip_2_of_2 of pds_continuation
      (** The second step of skipping a non-matching clause while stateless. *)
    | Value_capture_1_of_3
      (** Represents the first step of the value capture action.  This step
          pops and stores the value being captured. *)
    | Value_capture_2_of_3 of abs_filtered_value
      (** Represents the second step of the value capture action.  This step
          extracts the number of other stack elements to gather up before
          capturing the value. *)
    | Value_capture_3_of_3 of
        abs_filtered_value * pds_continuation list * bounded_capture_size
      (** Represents the third step of the value capture action.  This action
          collects other stack elements into a list until it has consumed as
          many as the original Capture stack element dictated.  It then pushes
          a value to the stack followed by all of the elements it collected. *)
    | Function_call_flow_validation of var * var * annotated_clause * annotated_clause * C.t * var
      (** Represents the validation of a function at a call site to ensure that
          we only explore exit nodes which apply in this context.  The first
          variable is the called function. The second variable is the argument
          passed to the function.  The given states are used to build the targets
          to which to jump once the function argument has been validated and
          once a function value has been discovered.  The third variable is the
          call site for which this validation is occurring. *)
    | Function_call_flow_validation_resolution_1_of_2 of var * var
      (** The first step of resolving function call flow validation.  The first
          variable is the call site; the second variable is the return variable
          for the called function's wiring node. *)
    | Function_call_flow_validation_resolution_2_of_2 of var * var
      (** We've captured the "RealFlow?" and now expect to see a value. *)
    | Function_closure_lookup of var * var
      (** Represents a function closure lookup.  The first variable is the
          parameter of the function; the second variable is the function itself.
          If the lookup variable does not match the parameter, then this lookup
          is for a non-local and we must search for the function's definition
          first. *)
    | Conditional_closure_lookup of var * var * pattern * bool
      (** Represents a conditional closure lookup.  The first variable is the
          formal parameter of the case branch that we are leaving from the top.
          The second variable is the subject of the pattern match.  The provided
          pattern is the pattern against which the subject was matched; the
          boolean is true if the match succeeded and false otherwise. *)
    | Conditional_subject_validation of 
        var * var * var * pattern * bool * annotated_clause * C.t
      (** Represents the handling of an exit wiring node for a conditional.  The
          first variable is the conditional site; the second variable is the
          return variable of the conditional branch.  The third variable is the
          subject of the conditional; it is followed by the conditional's
          pattern.  The boolean indicates whether this is the "then" branch
          (true) or the "else" branch (false).  The state and context refer to
          this wiring clause so a jump can be issued after the subject is
          validated in this branch. *)
    | Record_projection_lookup of var * var * ident
      (** Represents the start of a record projection.  If the first variable
          matches our lookup target, then we've discovered that we are looking
          up the projection of the ident label from a record stored in the
          second variable. *)
    | Record_projection_1_of_2
      (** Represents the processing of a record projection on the stack.  This
          action requires two steps: one to grab the record and one to grab the
          value. *)
    | Record_projection_2_of_2 of record_value * Pattern_set.t * Pattern_set.t
      (** The second step of handling record projection. *)
    | Function_filter_validation of var * abstract_function_value
      (** Represents the validation of filters for a function under lookup.  If
          the variable matches our lookup variable, any negative filters are
          admissible and can be erased (although positive filters cannot). *)
    | Record_filter_validation of
        var * record_value *
        annotated_clause * C.t * annotated_clause * C.t
      (** Represents the validation of filters for a record under lookup.  If
          the variable matches our lookup variable, we will perform a series
          of lookups on each field of the record to validate that this record
          does, in fact, exist.  Once those lookups succeed, the resulting
          record value will replace the lookup variable on the stack.  The
          PDS states given here are the source node (which follows the record
          assignment node in control flow) and the target node (which is the
          record assignment node itself); they are used to construct the
          subordinate lookups used in filter validation. *)
    | Int_filter_validation of var
      (** Represents the validation of filters for an integer under lookup.  If
          the variable matches our lookup variable, only the `int' filter on the
          positive set is admissible and anything but `int' in the negative
          filters is admissible and can be erased. *)
    | Bool_filter_validation of var * bool
      (** Represents the validation of filters for Boolean values under lookup.  If
          the variable matches our lookup variable, only the `true'/`false' filter on the
          positive set is admissible and anything but `true'/`false' in the negative
          filters is admissible and can be erased. *)
    | Empty_record_value_discovery of var
      (** Represents the discovery of an empty record value assuming that the
          current lookup variable matches the one provided here. *) 
    | Dereference_lookup of var * var
      (** Represents a dereferencing action.  The first variable is the lookup
          variable; the second variable is the variable it dereferences. *)
    | Cell_filter_validation of var * ref_value
      (** Represents the validation of filters for a cell under lookup.  If
          the variable matches our lookup variable, the cell (provided as the
          given abstract value) is pushed in its place. *)
    | Cell_dereference_1_of_2
      (** Represents the first step of dereferencing a located cell.  This is
          a stack reduction operation: the dereferenced cell must be on the
          value stack. *)
    | Cell_dereference_2_of_2 of ref_value
      (** Represents the second step of dereferencing a located cell.  The
          provided value is the cell in question. *)
    | Cell_update_alias_analysis_init_1_of_2 of var * pds_state * pds_state
      (** Represents the initialization of alias analysis for a given cell
          update.  This is used to determine if the update in question is
          modifying a cell for which we are looking via a different name.  The
          variable here is the cell being updated; the states are the source and
          target state of the original transition, respectively. *)
    | Cell_update_alias_analysis_init_2_of_2 of
        var * pds_state * pds_state * var * Pattern_set.t * Pattern_set.t
      (** Represents the second step of alias analysis initialization for a cell
          update.  The additional parameters are the contents of the
          continuation found during the first step. *)
    | Alias_analysis_resolution_1_of_5 of var
      (** Represents the final step of alias analysis which determines whether
          a cell may be an alias of the one currently under lookup.  The
          variable here is the name of the contents of the cell under
          consideration. *)
    | Alias_analysis_resolution_2_of_5 of var
      (** Alias analysis resolution after consuming the alias question from
          the stack. *)
    | Alias_analysis_resolution_3_of_5 of var * abstract_value
      (** Alias analysis resolution after consuming the first abstract value
          from the stack. *)
    | Alias_analysis_resolution_4_of_5 of var * bool
      (** Alias analysis resolution after consuming the second abstract value
          from the stack.  The boolean indicates whether the two abstract values
          were equal. *)
    | Alias_analysis_resolution_5_of_5 of
        var * bool * var * Pattern_set.t * Pattern_set.t
      (** Alias analysis resolution after consuming the lookup variable from the
          stack.  The additional elements here are the components of the lookup
          continuation. *)
    | Nonsideeffecting_nonmatching_clause_skip of var
      (** Represents the skip of a non-matching, non-stateful clause.  Although
          the rules indicate that this step should occur only when a deref
          exists on the stack, the rule overlaps with the stateless nonmatching
          clause skip in each occasion that a deref is not present.  So we
          simply drop that requirement here, as the overlap does not present
          a problem and it reduces the number of steps involved in performing
          this task.  The associated variable is the variable that a lookup must
          *not* match to be able to skip the clause. *)
    | Side_effect_search_init_1_of_2 of
        var * annotated_clause * C.t
      (** Represents the initialization of a search for side effects.  The
          provided variable must *not* be the lookup variable (since we'd be
          looking for an immediate definition in that case).  The clause and
          context represent the starting point of the side-effect search. *)
    | Side_effect_search_init_2_of_2 of
        var * Pattern_set.t * Pattern_set.t * annotated_clause * C.t
      (** Represents the initialization of a search for side effects.  At this
          point, all work has been performed except (1) validating the presence
          of a deref and (2) pushing the appropriate lookup continuations onto
          the stack. *)
    | Side_effect_search_nonmatching_clause_skip
      (** Represents the action of skipping any immediate, unannotated,
          non-update clause while searching for side effects. *)
    | Side_effect_search_exit_wiring
      (** Represents the action of moving into an exit wiring node during a
          side-effect search. *)
    | Side_effect_search_enter_wiring
      (** Represents the action of moving into an entrance wiring node during a
          side-effect search. *)
    | Side_effect_search_without_discovery
      (** Represents the end of a side-effect search which did not discover any
          relevant side effects. *)
    | Side_effect_search_alias_analysis_init of var * annotated_clause * C.t
      (** Represents the initialization of alias analysis for a cell update
          while in a side-effect search.  The variable is the cell being
          updated; the clause and context designate the state at which the
          alias analysis began. *)
    | Side_effect_search_alias_analysis_resolution_1_of_4 of var
      (** Represents the resolution of an alias analysis within a side-effect
          lookup.  The variable is the one being assigned to the cell. *)
    | Side_effect_search_alias_analysis_resolution_2_of_4 of var
      (** The second step of alias analysis resolution in a side-effect search.
          This step has consumed the "Alias?" question. *)
    | Side_effect_search_alias_analysis_resolution_3_of_4 of
        var * abstract_value
      (** The third step of alias analysis resolution in a side-effect search.
          The first abstract value has been consumed. *)
    | Side_effect_search_alias_analysis_resolution_4_of_4 of var * bool
      (** The last step of alias analysis resolution in a side-effect search.
          The variable is the one being assigned to a cell; the boolean
          indicates whether the particular value pair discovered here indicates
          aliasing or not. *)
    | Side_effect_search_escape_1_of_2
      (** The first step of processing a side-effect search escape.  This is
          used when the alias analysis of a cell update during a side-effect
          search successfully identifies a possible aliasing of the cell we are
          attempting to dereference.  This process is used to eliminate the
          stack frames which represent the side-effect search portion of the
          overall analysis so that lookup can proceed from the point at which
          the alias update is found. *)
    | Side_effect_search_escape_2_of_2 of var
      (** The second step of processing a side-effect search escape.  The
          variable is the one which was found to be the new value of the cell
          being dereferenced. *)
    | Side_effect_search_escape_completion_1_of_4
      (** Represents the completion of a side-effect search escape. *)
    | Side_effect_search_escape_completion_2_of_4 of var
      (** Represents the completion of a side-effect search escape.  The given
          variable is the one to which the aliased cell is being assigned. *)
    | Side_effect_search_escape_completion_3_of_4 of var
      (** Represents the completion of a side-effect search escape.  The given
          variable is the one to which the aliased cell is being assigned. *)
    | Side_effect_search_escape_completion_4_of_4 of var
      (** Represents the completion of a side-effect search escape.  The given
          variable is the one to which the aliased cell is being assigned. *)
    | Binary_operator_lookup_init of
        var * var * var * annotated_clause * C.t * annotated_clause * C.t
      (** Represents the kickstart of a process which looks up values for a
          binary operation.  The first variable above must be the
          current target of lookup.  The next two variables are the operands
          of the operation.  The remaining two pairs of values represent the
          source and target states of the DDPA edge. *)
    | Unary_operator_lookup_init of
        var * var * annotated_clause * C.t
      (** Represents the kickstart of a process which looks up values for a
          unary operation.  The first variable above must be the
          current target of lookup.  The second variable is the operand
          of the operation.  The state is the source states of the DDPA edge. *)
    | Binary_operator_resolution_1_of_4 of var * binary_operator
      (** Represents the start of the resolution of a binary operator after its
          operands have been found.  The variable here is the one under
          lookup. *)
    | Binary_operator_resolution_2_of_4 of var * binary_operator
      (** The second step of binary operator resolution.  This step
          collects the first operand. *)
    | Binary_operator_resolution_3_of_4 of var * binary_operator
      (** The third step of binary operator resolution.  This step
          collects the second operand. *)
    | Binary_operator_resolution_4_of_4 of var * binary_operator
      (** The forth step of binary operator resolution.  This step
          collects and checks the lookup variable. *)
    | Unary_operator_resolution_1_of_3 of var * unary_operator
      (** Represents the start of the resolution of a unary operator after its
          operands have been found.  The variable here is the one under
          lookup. *)
    | Unary_operator_resolution_2_of_3 of var * unary_operator
      (** The second step of unary operator resolution.  This step
          collects the operand. *)
    | Unary_operator_resolution_3_of_3 of var * unary_operator
      (** The third step of binary operator resolution.  This step
          collects and checks the lookup variable. *)
    [@@deriving ord]
  ;;
  
  let pp_pds_targeted_dynamic_pop_action action =
    match action with
    | Value_drop -> "Value_drop"
    | Value_discovery_2_of_2 -> "Value_discovery_2_of_2"
    | Variable_aliasing(x,x') ->
      Printf.sprintf "Variable_aliasing(%s,%s)" (pp_var x) (pp_var x')
    | Stateless_nonmatching_clause_skip_1_of_2(x) ->
      Printf.sprintf "Stateless_nonmatching_clause_skip_1_of_2(%s)"
        (pp_var x)
    | Stateless_nonmatching_clause_skip_2_of_2(k) ->
      Printf.sprintf "Stateless_nonmatching_clause_skip_2_of_2(%s)"
        (pp_pds_continuation k)
    | Value_capture_1_of_3 -> "Value_capture_1_of_3"
    | Value_capture_2_of_3(v) ->
      Printf.sprintf "Value_capture_1_of_2(%s)" (pp_abs_filtered_value v)
    | Value_capture_3_of_3(v,elements,size) ->
      Printf.sprintf "Value_capture_2_of_2(%s,%s,%d)"
        (pp_abs_filtered_value v) (pp_list pp_pds_continuation elements)
        (int_of_bounded_capture_size size)
    | Function_call_flow_validation(x_func,x_arg,acl0,c,ctx,x_site) ->
      Printf.sprintf "Function_call_flow_validation(%s,%s,%s,%s,%s,%s)"
        (pp_var x_func) (pp_var x_arg) (pp_annotated_clause acl0)
        (pp_annotated_clause c) (C.pp ctx) (pp_var x_site)
    | Function_call_flow_validation_resolution_1_of_2(x,x') ->
      Printf.sprintf "Function_call_flow_validation_resolution_1_of_2(%s,%s)"
      (pp_var x) (pp_var x')
    | Function_call_flow_validation_resolution_2_of_2(x,x') ->
      Printf.sprintf "Function_call_flow_validation_resolution_2_of_2(%s,%s)"
      (pp_var x) (pp_var x')
    | Function_closure_lookup(x'',xf) ->
      Printf.sprintf "Function_closure_lookup(%s,%s)"
        (pp_var x'') (pp_var xf)
    | Conditional_closure_lookup(x'',x1,p,b) ->
      Printf.sprintf "Conditional_closure_lookup(%s,%s,%s,%b)"
        (pp_var x'') (pp_var x1) (pp_pattern p) b
    | Conditional_subject_validation(x,x',x1,pat,then_branch,acl1,ctx) ->
      Printf.sprintf "Conditional_subject_validation(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x) (pp_var x') (pp_var x1) (pp_pattern pat)
        (string_of_bool then_branch) (pp_annotated_clause acl1) (C.pp ctx)
    | Record_projection_lookup(x,x',l) ->
      Printf.sprintf "Record_projection_lookup(%s,%s,%s)"
        (pp_var x) (pp_var x') (pp_ident l)
    | Record_projection_1_of_2 -> "Record_projection_1_of_2"
    | Record_projection_2_of_2(r,patsp,patsn) ->
      Printf.sprintf "Record_projection_2_of_2(%s,%s,%s)"
        (pp_record_value r) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Function_filter_validation(x,v) ->
      Printf.sprintf "Function_filter_validation(%s,%s)"
        (pp_var x) (pp_abstract_function_value v)
    | Record_filter_validation(x,r,acl1,ctx1,acl0,ctx0) ->
      Printf.sprintf "Record_filter_validation(%s,%s,%s,%s,%s,%s)"
        (pp_var x) (pp_record_value r)
        (pp_annotated_clause acl1) (C.pp ctx1)
        (pp_annotated_clause acl0) (C.pp ctx0)
    | Int_filter_validation(x) ->
      Printf.sprintf "Int_filter_validation(%s)"
        (pp_var x)
    | Bool_filter_validation(x,b) ->
      Printf.sprintf "Bool_filter_validation(%s,%s)"
        (pp_var x) (string_of_bool b)
    | Empty_record_value_discovery(x) ->
      Printf.sprintf "Empty_record_value_discovery(%s)" (pp_var x)
    | Dereference_lookup(x,x') ->
      Printf.sprintf "Dereference_lookup(%s,%s)" (pp_var x) (pp_var x') 
    | Cell_filter_validation(x,cell) ->
      Printf.sprintf "Cell_filter_validation(%s,%s)"
        (pp_var x) (pp_ref_value cell)
    | Cell_dereference_1_of_2 -> "Cell_dereference_1_of_2"
    | Cell_dereference_2_of_2(cell) ->
      Printf.sprintf "Cell_dereference_2_of_2(%s)" (pp_ref_value cell)
    | Cell_update_alias_analysis_init_1_of_2(x',s1,s2) ->
      Printf.sprintf "Cell_update_alias_analysis_init_1_of_2(%s,%s,%s)"
        (pp_var x') (pp_pds_state s1) (pp_pds_state s2)
    | Cell_update_alias_analysis_init_2_of_2(x',s1,s2,x,patsp,patsn) ->
      Printf.sprintf "Cell_update_alias_analysis_init_2_of_2(%s,%s,%s,%s,%s,%s)"
        (pp_var x') (pp_pds_state s1) (pp_pds_state s2)
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Alias_analysis_resolution_1_of_5(x'') ->
      Printf.sprintf "AAR1(%s)" (pp_var x'')
    | Alias_analysis_resolution_2_of_5(x'') ->
      Printf.sprintf "AAR2(%s)" (pp_var x'')
    | Alias_analysis_resolution_3_of_5(x'',v) ->
      Printf.sprintf "AAR3(%s,%s)"
        (pp_var x'') (pp_abstract_value v)
    | Alias_analysis_resolution_4_of_5(x'',b) ->
      Printf.sprintf "AAR4(%s,%s)"
        (pp_var x'') (string_of_bool b)
    | Alias_analysis_resolution_5_of_5(x'',b,x,patsp,patsn) ->
      Printf.sprintf "AAR5(%s,%s,%s,%s,%s)"
        (pp_var x'') (string_of_bool b) (pp_var x)
        (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Nonsideeffecting_nonmatching_clause_skip(x'') ->
      Printf.sprintf "Nonsideeffecting_nonmatching_clause_skip(%s)"
        (pp_var x'')
    | Side_effect_search_init_1_of_2(x,acl0,ctx) ->
      Printf.sprintf "Side_effect_search_init_1_of_2(%s,%s,%s)"
        (pp_var x) (pp_annotated_clause acl0) (C.pp ctx)
    | Side_effect_search_init_2_of_2(x,patsp,patsn,acl0,ctx) ->
      Printf.sprintf "Side_effect_search_init_2_of_2(%s,%s,%s,%s,%s)"
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
        (pp_annotated_clause acl0) (C.pp ctx)
    | Side_effect_search_nonmatching_clause_skip ->
      "Side_effect_search_nonmatching_clause_skip"
    | Side_effect_search_exit_wiring ->
      "Side_effect_search_exit_wiring"
    | Side_effect_search_enter_wiring ->
      "Side_effect_search_enter_wiring"
    | Side_effect_search_without_discovery ->
      "Side_effect_search_without_discovery"
    | Side_effect_search_alias_analysis_init(x',acl,ctx) ->
      Printf.sprintf "Side_effect_search_alias_analysis_init(%s,%s,%s)"
        (pp_var x') (pp_annotated_clause acl) (C.pp ctx)
    | Side_effect_search_alias_analysis_resolution_1_of_4 x'' ->
      Printf.sprintf "Side_effect_search_alias_analysis_resolution_1_of_4(%s)"
        (pp_var x'')
    | Side_effect_search_alias_analysis_resolution_2_of_4(x'') ->
      Printf.sprintf "Side_effect_search_alias_analysis_resolution_2_of_4(%s)"
        (pp_var x'')
    | Side_effect_search_alias_analysis_resolution_3_of_4(x'',v) ->
      Printf.sprintf
        "Side_effect_search_alias_analysis_resolution_3_of_4(%s,%s)"
        (pp_var x'') (pp_abstract_value v)
    | Side_effect_search_alias_analysis_resolution_4_of_4(x'',is_alias) ->
      Printf.sprintf
        "Side_effect_search_alias_analysis_resolution_4_of_4(%s,%s)"
        (pp_var x'') (string_of_bool is_alias)
    | Side_effect_search_escape_1_of_2 ->
      "Side_effect_search_escape_1_of_2"
    | Side_effect_search_escape_2_of_2 x'' ->
      Printf.sprintf "Side_effect_search_escape_2_of_2(%s)" (pp_var x'')
    | Side_effect_search_escape_completion_1_of_4 ->
      "Side_effect_search_escape_completion_1_of_4"
    | Side_effect_search_escape_completion_2_of_4 x ->
      Printf.sprintf "Side_effect_search_escape_completion_2_of_4(%s)"
        (pp_var x)
    | Side_effect_search_escape_completion_3_of_4 x ->
      Printf.sprintf "Side_effect_search_escape_completion_3_of_4(%s)"
        (pp_var x)
    | Side_effect_search_escape_completion_4_of_4 x ->
      Printf.sprintf "Side_effect_search_escape_completion_4_of_4(%s)"
        (pp_var x)
    | Binary_operator_lookup_init(x1,x2,x3,acl1,ctx1,acl0,ctx0) ->
      Printf.sprintf "Binary_operator_lookup_init(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x1) (pp_var x2) (pp_var x3)
        (pp_annotated_clause acl1) (C.pp ctx1)
        (pp_annotated_clause acl0) (C.pp ctx0)
    | Unary_operator_lookup_init(x1,x2,acl0,ctx0) ->
      Printf.sprintf "Unary_operator_lookup_init(%s,%s,%s,%s)"
        (pp_var x1) (pp_var x2)
        (pp_annotated_clause acl0) (C.pp ctx0)
    | Binary_operator_resolution_1_of_4(x1,op) ->
      Printf.sprintf "Binary_operator_resolution_1_of_4(%s,%s)"
        (pp_var x1) (pp_binary_operator op)
    | Binary_operator_resolution_2_of_4(x1,op) ->
      Printf.sprintf "Binary_operator_resolution_2_of_4(%s,%s)"
        (pp_var x1) (pp_binary_operator op)
    | Binary_operator_resolution_3_of_4(x1,op) ->
      Printf.sprintf "Binary_operator_resolution_3_of_4(%s,%s)"
        (pp_var x1) (pp_binary_operator op)
    | Binary_operator_resolution_4_of_4(x1,op) ->
      Printf.sprintf "Binary_operator_resolution_4_of_4(%s,%s)"
        (pp_var x1) (pp_binary_operator op)
    | Unary_operator_resolution_1_of_3(x1,op) ->
      Printf.sprintf "Unary_operator_resolution_1_of_3(%s,%s)"
        (pp_var x1) (pp_unary_operator op)
    | Unary_operator_resolution_2_of_3(x1,op) ->
      Printf.sprintf "Unary_operator_resolution_2_of_3(%s,%s)"
        (pp_var x1) (pp_unary_operator op)
    | Unary_operator_resolution_3_of_3(x1,op) ->
      Printf.sprintf "Unary_operator_resolution_3_of_3(%s,%s)"
        (pp_var x1) (pp_unary_operator op)
  ;;

  let ppa_pds_targeted_dynamic_pop_action action =
    match action with
    | Value_drop -> "ValDrop"
    | Value_discovery_2_of_2 -> "ValDisc2"
    | Variable_aliasing(x,x') ->
      Printf.sprintf "VAlias(%s,%s)" (pp_var x) (pp_var x')
    | Stateless_nonmatching_clause_skip_1_of_2(x) ->
      Printf.sprintf "SNMCS1(%s)"
        (pp_var x)
    | Stateless_nonmatching_clause_skip_2_of_2(k) ->
      Printf.sprintf "SNMCS2(%s)"
        (ppa_pds_continuation k)
    | Value_capture_1_of_3 -> "VCap1"
    | Value_capture_2_of_3(v) ->
      Printf.sprintf "VCap2(%s)" (pp_abs_filtered_value v)
    | Value_capture_3_of_3(v,elements,size) ->
      Printf.sprintf "VCap3(%s,%s,%d)"
        (pp_abs_filtered_value v) (pp_list ppa_pds_continuation elements)
        (int_of_bounded_capture_size size)
    | Function_call_flow_validation(x_func,x_arg,acl0,c,ctx,x_site) ->
      Printf.sprintf "FCFV(%s,%s,%s,%s,%s,%s)"
        (pp_var x_func) (pp_var x_arg) (pp_annotated_clause acl0)
        (pp_annotated_clause c) (C.pp ctx) (pp_var x_site)
    | Function_call_flow_validation_resolution_1_of_2(x,x') ->
      Printf.sprintf "FCFVR1(%s,%s)"
      (pp_var x) (pp_var x')
    | Function_call_flow_validation_resolution_2_of_2(x,x') ->
      Printf.sprintf "FCFVR2(%s,%s)"
      (pp_var x) (pp_var x')
    | Function_closure_lookup(x'',xf) ->
      Printf.sprintf "FunCL(%s,%s)"
        (pp_var x'') (pp_var xf)
    | Conditional_closure_lookup(x'',x1,p,b) ->
      Printf.sprintf "CondCL(%s,%s,%s,%b)"
        (pp_var x'') (pp_var x1) (pp_pattern p) b
    | Conditional_subject_validation(x,x',x1,pat,then_branch,acl1,ctx) ->
      Printf.sprintf "CondSV(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x) (pp_var x') (pp_var x1) (pp_pattern pat)
        (string_of_bool then_branch) (ppa_annotated_clause acl1) (C.pp ctx)
    | Record_projection_lookup(x,x',l) ->
      Printf.sprintf "RProjL(%s,%s,%s)"
        (pp_var x) (pp_var x') (pp_ident l)
    | Record_projection_1_of_2 -> "RProj1"
    | Record_projection_2_of_2(r,patsp,patsn) ->
      Printf.sprintf "RProj2(%s,%s,%s)"
        (pp_record_value r) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Function_filter_validation(x,f) ->
      Printf.sprintf "FunFilVal(%s,%s)"
        (pp_var x) (pp_abstract_function_value f)
    | Record_filter_validation(x,r,acl1,ctx1,acl0,ctx0) ->
      Printf.sprintf "RecFilVal(%s,%s,%s,%s,%s,%s)"
        (pp_var x) (pp_record_value r)
        (pp_annotated_clause acl1) (C.pp ctx1)
        (pp_annotated_clause acl0) (C.pp ctx0)
    | Int_filter_validation(x) ->
      Printf.sprintf "IntFilVal(%s)"
        (pp_var x)
    | Bool_filter_validation(x,b) ->
      Printf.sprintf "BoolFilVal(%s,%s)"
        (pp_var x) (string_of_bool b)
    | Empty_record_value_discovery(x) ->
      Printf.sprintf "ERValDisc(%s)" (pp_var x)
    | Dereference_lookup(x,x') ->
      Printf.sprintf "Deref(%s,%s)" (pp_var x) (pp_var x')
    | Cell_filter_validation(x,cell) ->
      Printf.sprintf "CellFilVal(%s,%s)" (pp_var x) (pp_ref_value cell)
    | Cell_dereference_1_of_2 -> "CDr1"
    | Cell_dereference_2_of_2(cell) ->
      Printf.sprintf "CDr2(%s)" (pp_ref_value cell)
    | Cell_update_alias_analysis_init_1_of_2(x',s1,s2) ->
      Printf.sprintf "CUAA1(%s,%s,%s)"
        (pp_var x') (pp_pds_state s1) (pp_pds_state s2)
    | Cell_update_alias_analysis_init_2_of_2(x',s1,s2,x,patsp,patsn) ->
      Printf.sprintf "CUAA2(%s,%s,%s,%s,%s,%s)"
        (pp_var x') (pp_pds_state s1) (pp_pds_state s2)
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Alias_analysis_resolution_1_of_5(x'') ->
      Printf.sprintf "AAR1(%s)" (pp_var x'')
    | Alias_analysis_resolution_2_of_5(x'') ->
      Printf.sprintf "AAR2(%s)" (pp_var x'')
    | Alias_analysis_resolution_3_of_5(x'',v) ->
      Printf.sprintf "AAR3(%s,%s)"
        (pp_var x'') (pp_abstract_value v)
    | Alias_analysis_resolution_4_of_5(x'',b) ->
      Printf.sprintf "AAR4(%s,%s)"
        (pp_var x'') (string_of_bool b)
    | Alias_analysis_resolution_5_of_5(x'',b,x,patsp,patsn) ->
      Printf.sprintf "AAR5(%s,%s,%s,%s,%s)"
        (pp_var x'') (string_of_bool b) (pp_var x)
        (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Nonsideeffecting_nonmatching_clause_skip(x'') ->
      Printf.sprintf "NNCS(%s)" (pp_var x'')
    | Side_effect_search_init_1_of_2(x,acl0,ctx) ->
      Printf.sprintf "SESI1(%s,%s,%s)"
        (pp_var x) (ppa_annotated_clause acl0) (C.pp ctx)
    | Side_effect_search_init_2_of_2(x,patsp,patsn,acl0,ctx) ->
      Printf.sprintf "SESI2(%s,%s,%s,%s,%s)"
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
        (ppa_annotated_clause acl0) (C.pp ctx)
    | Side_effect_search_nonmatching_clause_skip -> "SESNCS"
    | Side_effect_search_exit_wiring -> "SESXW"
    | Side_effect_search_enter_wiring -> "SESEW"
    | Side_effect_search_without_discovery -> "SESWD"
    | Side_effect_search_alias_analysis_init(x',acl,ctx) ->
      Printf.sprintf "SESAAI(%s,%s,%s)"
        (pp_var x') (pp_annotated_clause acl) (C.pp ctx)
    | Side_effect_search_alias_analysis_resolution_1_of_4 x'' ->
      Printf.sprintf "SESAAR1(%s)"
        (pp_var x'')
    | Side_effect_search_alias_analysis_resolution_2_of_4(x'') ->
      Printf.sprintf "SESAAR2(%s)" (pp_var x'')
    | Side_effect_search_alias_analysis_resolution_3_of_4(x'',v) ->
      Printf.sprintf "SESAAR3(%s,%s)"
        (pp_var x'') (pp_abstract_value v)
    | Side_effect_search_alias_analysis_resolution_4_of_4(x'',is_alias) ->
      Printf.sprintf "SESAAR4(%s,%s)"
        (pp_var x'') (string_of_bool is_alias)
    | Side_effect_search_escape_1_of_2 -> "SESE1"
    | Side_effect_search_escape_2_of_2 x'' ->
      Printf.sprintf "SESE2(%s)" (pp_var x'')
    | Side_effect_search_escape_completion_1_of_4 -> "SESEC1"
    | Side_effect_search_escape_completion_2_of_4 x ->
      Printf.sprintf "SESEC2(%s)" (pp_var x)
    | Side_effect_search_escape_completion_3_of_4 x ->
      Printf.sprintf "SESEC3(%s)" (pp_var x)
    | Side_effect_search_escape_completion_4_of_4 x ->
      Printf.sprintf "SESEC4(%s)" (pp_var x)
    | Binary_operator_lookup_init(x1,x2,x3,acl1,ctx1,acl0,ctx0) ->
      Printf.sprintf "BinOpInit(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x1) (pp_var x2) (pp_var x3)
        (ppa_annotated_clause acl1) (C.pp ctx1)
        (ppa_annotated_clause acl0) (C.pp ctx0)
    | Unary_operator_lookup_init(x1,x2,acl0,ctx0) ->
      Printf.sprintf "UnOpInit(%s,%s,%s,%s)"
        (pp_var x1) (pp_var x2)
        (ppa_annotated_clause acl0) (C.pp ctx0)
    | Binary_operator_resolution_1_of_4(x1,op) ->
      Printf.sprintf "BinOpRes1(%s,%s)" (pp_var x1) (pp_binary_operator op)
    | Binary_operator_resolution_2_of_4(x1,op) ->
      Printf.sprintf "BinOpRes2(%s,%s)" (pp_var x1) (pp_binary_operator op)
    | Binary_operator_resolution_3_of_4(x1,op) ->
      Printf.sprintf "BinOpRes3(%s,%s)" (pp_var x1) (pp_binary_operator op)
    | Binary_operator_resolution_4_of_4(x1,op) ->
      Printf.sprintf "BinOpRes4(%s,%s)" (pp_var x1) (pp_binary_operator op)
    | Unary_operator_resolution_1_of_3(x1,op) ->
      Printf.sprintf "UnOpRes1(%s,%s)" (pp_var x1) (pp_unary_operator op)
    | Unary_operator_resolution_2_of_3(x1,op) ->
      Printf.sprintf "UnOpRes2(%s,%s)" (pp_var x1) (pp_unary_operator op)
    | Unary_operator_resolution_3_of_3(x1,op) ->
      Printf.sprintf "UnOpRes3(%s,%s)" (pp_var x1) (pp_unary_operator op)
  ;;

  type pds_untargeted_dynamic_pop_action =
    | Do_jump
      (** The action for performing basic jump operations. *)
    | Value_discovery_1_of_2
      (** Represents the rule that, if a value is the only element on the stack,
          we transition to one of the result states.  To determine that the
          value is the only element, we must be able to pop the special "bottom"
          stack element, so this is the first step of the process (which pops
          the value).  Because the value dictates the target of the second
          step, this is an untargeted action.  The second step is targeted. *)
    [@@deriving ord]
  ;;
  
  let pp_pds_untargeted_dynamic_pop_action action =
    match action with
    | Do_jump -> "Do_jump"
    | Value_discovery_1_of_2 -> "VDisc1"
  ;;

  let ppa_pds_untargeted_dynamic_pop_action action =
    match action with
    | Do_jump -> "Do_jump"
    | Value_discovery_1_of_2 -> "VDisc1"
  ;;

  module Dph =
  struct
    type stack_element = pds_continuation;;
    type state = pds_state;;
    type targeted_dynamic_pop_action = pds_targeted_dynamic_pop_action;;
    type untargeted_dynamic_pop_action = pds_untargeted_dynamic_pop_action;;
    type stack_action =
      ( stack_element
      , targeted_dynamic_pop_action
      ) pds_stack_action
    ;;
    let compare_targeted_dynamic_pop_action =
      compare_pds_targeted_dynamic_pop_action;;
    let pp_targeted_dynamic_pop_action = pp_pds_targeted_dynamic_pop_action;;
    let ppa_targeted_dynamic_pop_action = ppa_pds_targeted_dynamic_pop_action;;
    let compare_untargeted_dynamic_pop_action =
      compare_pds_untargeted_dynamic_pop_action;;
    let pp_untargeted_dynamic_pop_action =
      pp_pds_untargeted_dynamic_pop_action;;
    let ppa_untargeted_dynamic_pop_action =
      ppa_pds_untargeted_dynamic_pop_action;;
    let perform_targeted_dynamic_pop element action =
      Logger_utils.lazy_bracket_log (lazy_logger `trace)
        (fun () ->
          Printf.sprintf "perform_targeted_dynamic_pop (%s) (%s)"
            (pp_pds_continuation element)
            (pp_pds_targeted_dynamic_pop_action action))
        (fun results ->
          String_utils.concat_sep_delim "[" "]" ", "
            (
              results
              |> Enum.clone
              |> Enum.map (String_utils.pp_list @@
                  pp_pds_stack_action pp_pds_continuation
                    pp_pds_targeted_dynamic_pop_action)
            )
        )
      @@ fun () ->
      Nondeterminism_monad.enum @@
      let open Nondeterminism_monad in
      match action with
      | Value_drop ->
        let%orzero Continuation_value _ = element in
        return []
      | Value_discovery_2_of_2 ->
        let%orzero Bottom_of_stack = element in
        return []
      | Variable_aliasing(x2,x1) ->
        let%orzero (Lookup_var(x',patsp,patsn)) = element in
        [%guard equal_var x' x2];
        (* We're looking for x2 and we've discovered here that it's aliased to
           x1. *)
        return [Push(Lookup_var(x1,patsp,patsn))]
      | Stateless_nonmatching_clause_skip_1_of_2 x'' ->
        let%orzero (Lookup_var(x,_,_)) = element in
        [%guard (not @@ equal_var x x'')];
        (* We're looking for a variable which does not match the one in this
           clause.  If we're stateless, that'll be fine. *)
        return [Pop_dynamic_targeted(
                  Stateless_nonmatching_clause_skip_2_of_2 element)]
      | Stateless_nonmatching_clause_skip_2_of_2 element' ->
        begin
          match element with
          | Deref(_,_) ->
            (* This means we're in a stateful mode.  Stateless non-matching
               clause skip is inappropriate here. *)
            zero ()
          | _ ->
            (* We're not in a stateful mode, so we can skip the clause.  We
               still have to put these elements back on the stack, though. *)
            return [Push(element);Push(element')]
        end
      | Value_capture_1_of_3 ->
        let%orzero (Continuation_value abs_filtered_value) = element in
        return [ Pop_dynamic_targeted(
                    Value_capture_2_of_3(abs_filtered_value)) ]
      | Value_capture_2_of_3 fv ->
        let%orzero Capture(size) = element in
        return [ Pop_dynamic_targeted(Value_capture_3_of_3(fv,[],size)) ]
      | Value_capture_3_of_3(fv,collected_elements,size) ->
        let n = int_of_bounded_capture_size size in
        if n > 1
        then
          begin
            let size' = make_bounded_capture_size (n-1) in
            return
              [Pop_dynamic_targeted
                (Value_capture_3_of_3(fv,element::collected_elements,size'))]
          end
        else
          begin
            let pushes =
              List.map (fun x -> Push x) (element::collected_elements)
            in
            return @@ (Push (Continuation_value fv))::pushes 
          end
      | Function_call_flow_validation(x2'',x3'',acl0,c,ctx,x) ->
        let%orzero (Lookup_var(x',_,_)) = element in
        [%guard (equal_var x x')];
        return [ Push(element)
               ; Push(Real_flow_huh)
               ; Push(Jump(acl0,ctx))
               ; Push(Capture(make_bounded_capture_size 2))
               ; Push(Lookup_var(x2'',Pattern_set.empty,Pattern_set.empty))
               ; Push(Jump(c,ctx))
               ; Push(Lookup_var(x3'',Pattern_set.empty,Pattern_set.empty))
               ]
      | Function_call_flow_validation_resolution_1_of_2(x,x') ->
        let%orzero Real_flow_huh = element in
        let action = Function_call_flow_validation_resolution_2_of_2(x,x') in
        return [ Pop_dynamic_targeted(action) ]
      | Function_call_flow_validation_resolution_2_of_2(x,x') ->
        let%orzero Continuation_value(v) = element in
        let Abs_filtered_value(v',_,_) = v in
        let%orzero
          Abs_value_function(Abs_function_value(_,Abs_expr(acls))) = v'
        in
        [%guard (equal_var x' @@ rv acls)];
        return [ Pop_dynamic_targeted(Variable_aliasing(x,x')) ]
      | Function_closure_lookup(x'',xf) ->
        let%orzero (Lookup_var(x,_,_)) = element in
        [%guard (not @@ equal_var x x'')];
        (* We're looking for a non-local variable.  Push a lookup for the
           function. *)
        return [ Push(element)
               ; Push(Lookup_var(xf,Pattern_set.empty,Pattern_set.empty))
               ]
      | Conditional_closure_lookup(x',x1,pat,positive_side) ->
        let%orzero (Lookup_var(x,patsp,patsn)) = element in
        if not @@ (equal_var x x' || equal_var x x1)
        then return [Push(element)]
        else
          let (patsp',patsn') =
            if positive_side
            then (Pattern_set.add pat patsp,patsn)
            else (patsp,Pattern_set.add pat patsn)
          in
          return [Push(Lookup_var(x1,patsp',patsn'))]
      | Conditional_subject_validation(x,x',x1,pat,then_branch,acl1,ctx) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [%guard (equal_var x0 x)];
        let patsp',patsn' =
          if then_branch
          then (Pattern_set.singleton pat, Pattern_set.empty)
          else (Pattern_set.empty, Pattern_set.singleton pat)
        in
        return [ Push(Lookup_var(x',patsp,patsn))
               ; Push(Jump(acl1,ctx))
               ; Push(Lookup_var(x1,patsp',patsn'))
               ]
      | Record_projection_lookup(x,x',l) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [%guard (equal_var x0 x)];
        return [ Push(Project(l,patsp,patsn))
               ; Push(Lookup_var(x',Pattern_set.empty,Pattern_set.empty))
               ]
      | Record_projection_1_of_2 ->
        let%orzero (Continuation_value fv) = element in
        let%orzero (Abs_filtered_value(Abs_value_record(r),patsp,patsn)) = fv in
        return [ Pop_dynamic_targeted(Record_projection_2_of_2(r,patsp,patsn)) ]
      | Record_projection_2_of_2(Record_value(m) as r,patsp0,patsn0) ->
        [%guard (is_record_pattern_set patsp0)];
        let%orzero (Project(l,patsp1,patsn1)) = element in
        [%guard (Ident_map.mem l m)];
        (* FIXME: the following isn't in the spec, but maybe it should be... just here to test things for now *)
        [% guard (not @@
                      Pattern_set.mem (Record_pattern Ident_map.empty) patsn0) ];
        let%bind patsn2 = negative_pattern_set_selection r patsn0 in
        [%guard (is_record_pattern_set patsn2)];
        let x' = Ident_map.find l m in
        let patsp' = Pattern_set.union patsp1 @@
                        pattern_set_projection patsp0 l in
        let patsn' = Pattern_set.union patsn1 @@
                        pattern_set_projection patsn2 l in
        return @@ [ Push(Lookup_var(x',patsp',patsn')) ]
      | Function_filter_validation(x,v) ->
        let%orzero (Lookup_var(x0,patsp,_)) = element in
        [% guard (equal_var x x0) ];
        [% guard (Pattern_set.is_empty patsp) ];
        let value = Abs_value_function(v) in
        let abs_filtered_value =
          Abs_filtered_value(value,Pattern_set.empty,Pattern_set.empty)
        in
        return [ Push(Continuation_value abs_filtered_value) ]
      | Record_filter_validation(x,r,acl1,ctx1,acl0,ctx0) ->
        (* Make sure we're looking for this variable. *)
        let%orzero (Lookup_var(x0,patsp0,patsn0)) = element in
        [% guard (equal_var x x0) ];
        [% guard (is_record_pattern_set patsp0)];
        (* FIXME: the following isn't in the spec, but maybe it should be... just here to test things for now *)
        [% guard (not @@
                    Pattern_set.mem (Record_pattern Ident_map.empty) patsn0) ];
        let%bind patsn2 = negative_pattern_set_selection r patsn0 in
        let pattern_set_labels = labels_in_pattern_set patsp0 in
        let record_labels = labels_in_record r in
        let Record_value(m) = r in
        [%guard (Ident_set.subset pattern_set_labels record_labels) ];
        let make_k'' l =
          let x'' = Ident_map.find l m in
          List.enum [ Push(Lookup_var( x''
                                     , pattern_set_projection patsp0 l
                                     , pattern_set_projection patsn2 l))
                    ; Push(Jump(acl1,ctx1))
                    ]
        in
        let first_pushes =
          List.enum [ Push(Continuation_value(Abs_filtered_value(
                              Abs_value_record(r), patsp0, patsn2)))
                    ; Push(Jump(acl0,ctx0))
                    ]
        in
        let all_pushes =
          record_labels
          |> Ident_set.enum
          |> Enum.map make_k''
          |> Enum.concat
          |> Enum.append first_pushes
        in
        return @@ List.of_enum all_pushes
      | Int_filter_validation(x) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        [% guard (Pattern_set.subset patsp (Pattern_set.singleton Int_pattern)) ];
        [% guard (not @@ Pattern_set.mem Int_pattern patsn) ];
        let abs_filtered_value =
          Abs_filtered_value(Abs_value_int,Pattern_set.empty,Pattern_set.empty)
        in
        return [ Push(Continuation_value abs_filtered_value) ]
      | Bool_filter_validation(x,b) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        [% guard (Pattern_set.subset patsp (Pattern_set.singleton (Bool_pattern(b)))) ];
        [% guard (not @@ Pattern_set.mem (Bool_pattern(b)) patsn) ];
        let abs_filtered_value =
          Abs_filtered_value(Abs_value_bool(b),Pattern_set.empty,Pattern_set.empty)
        in
        return [ Push(Continuation_value abs_filtered_value) ]
      | Empty_record_value_discovery(x) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [%guard (equal_var x x0)];
        let empty_record = Abs_value_record(Record_value Ident_map.empty) in
        let empty_record_pattern = Record_pattern Ident_map.empty in
        [% guard (Pattern_set.subset
                    patsp (Pattern_set.singleton empty_record_pattern)) ];
        [% guard (not @@ Pattern_set.mem empty_record_pattern patsn) ];
        return [ Push(Continuation_value(Abs_filtered_value(
                        empty_record,Pattern_set.empty,Pattern_set.empty))) ]
      | Dereference_lookup(x,x') ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        return [ Push(Deref(patsp, patsn))
               ; Push(Lookup_var(x', Pattern_set.empty, Pattern_set.empty))
               ]
      | Cell_filter_validation(x,cell) ->
        let%orzero (Lookup_var(x0,patsp,_)) = element in
        [% guard (equal_var x x0) ];
        [% guard (Pattern_set.is_empty patsp) ];
        let value = Abs_value_ref(cell) in
        return [ Push(Continuation_value(Abs_filtered_value(
                        value,Pattern_set.empty,Pattern_set.empty))) ]
      | Cell_dereference_1_of_2 ->
        let%orzero
          (Continuation_value(Abs_filtered_value(
              Abs_value_ref(cell),patsp,patsn))) = element
        in
        [% guard (Pattern_set.is_empty patsp) ];
        [% guard (Pattern_set.is_empty patsn) ];
        (* From here, we need another stack frame element to confirm the
           dereference action and obtain its filters. *)
        return [ Pop_dynamic_targeted(Cell_dereference_2_of_2(cell)) ]
      | Cell_dereference_2_of_2(cell) ->
        let%orzero (Deref(patsp,patsn)) = element in
        let Ref_value(x') = cell in
        return [ Push(Lookup_var(x', patsp, patsn)) ]
      | Cell_update_alias_analysis_init_1_of_2(x',source_state,target_state) ->
        let%orzero (Lookup_var(x,patsp,patsn)) = element in
        return [ Pop_dynamic_targeted(
                    Cell_update_alias_analysis_init_2_of_2(
                      x',source_state,target_state,x,patsp,patsn)) ]
      | Cell_update_alias_analysis_init_2_of_2(
          x',source_state,target_state,x,patsp0,patsn0) ->
        let%orzero (Deref _) = element in
        let%orzero Program_point_state(acl1,ctx1) = source_state in
        let%orzero Program_point_state(acl0,ctx0) = target_state in
        (* The lists below are in reverse order of their presentation in the
           formal rules because we are not directly modifying the stack;
           instead, we are pushing stack elements one at a time. *)
        let capture_size_5 = make_bounded_capture_size 5 in
        let capture_size_2 = make_bounded_capture_size 2 in
        let k1'' = [ Capture capture_size_5 ; Lookup_var(x,patsp0,patsn0) ] in
        let k2'' = [ Capture capture_size_2
                   ; Lookup_var(x',Pattern_set.empty,Pattern_set.empty)
                   ; Jump(acl1, ctx1) ] in
        let k3'' = [ Alias_huh ; Jump(acl0,ctx0) ] in
        let k0 = [ element ; Lookup_var(x,patsp0,patsn0) ] in
        return @@ List.map (fun x -> Push x) @@
          k0 @ k3'' @ k2'' @ k1''
      | Alias_analysis_resolution_1_of_5(x'') ->
        let%orzero Alias_huh = element in
        return [ Pop_dynamic_targeted
                  (Alias_analysis_resolution_2_of_5(x'')) ]
      | Alias_analysis_resolution_2_of_5(x'') ->
        let%orzero
          Continuation_value(Abs_filtered_value(v,patsp,patsn)) = element
        in
        [%guard (Pattern_set.is_empty patsp)];
        [%guard (Pattern_set.is_empty patsn)];
        return [ Pop_dynamic_targeted
                  (Alias_analysis_resolution_3_of_5(x'', v)) ]
      | Alias_analysis_resolution_3_of_5(x'',v) ->
        let%orzero
          Continuation_value(Abs_filtered_value(v',patsp,patsn)) = element
        in
        [%guard (Pattern_set.is_empty patsp)];
        [%guard (Pattern_set.is_empty patsn)];
        let equal_values = equal_abstract_value v v' in
        return [ Pop_dynamic_targeted
                  (Alias_analysis_resolution_4_of_5(x'',equal_values)) ]
      | Alias_analysis_resolution_4_of_5(x'',equal_values) ->
        let%orzero Lookup_var(x,patsp0,patsn0) = element in
        return [ Pop_dynamic_targeted
                  (Alias_analysis_resolution_5_of_5(
                    x'',equal_values,x,patsp0,patsn0)) ]
      | Alias_analysis_resolution_5_of_5(x'',equal_values,x,patsp0,patsn0) ->
        let%orzero Deref(patsp1,patsn1) = element in
        if equal_values
        then
          return [ Push(Lookup_var(x'',patsp1,patsn1)) ]
        else
          return [ Push(Deref(patsp1,patsn1))
                 ; Push(Lookup_var(x,patsp0,patsn0)) ]
      | Nonsideeffecting_nonmatching_clause_skip(x'') ->
        let%orzero Lookup_var(x,_,_) = element in
        [%guard (not @@ equal_var x x'')];
        return [Push element]
      | Side_effect_search_init_1_of_2(x'',acl0,ctx) ->
        let%orzero Lookup_var(x,patsp,patsn) = element in
        [%guard (not @@ equal_var x x'')];
        return [ Pop_dynamic_targeted(
                  Side_effect_search_init_2_of_2(x,patsp,patsn,acl0,ctx)) ]
      | Side_effect_search_init_2_of_2(x,patsp,patsn,acl0,ctx) ->
        let%orzero Deref _ = element in
        return [ Push element ; Push (Lookup_var(x,patsp,patsn))
               ; Push Side_effect_search_start
               ; Push (Side_effect_lookup_var(x,patsp,patsn,acl0,ctx))
               ]
      | Side_effect_search_nonmatching_clause_skip ->
        let%orzero (Side_effect_lookup_var _) = element in
        return [ Push element ]
      | Side_effect_search_exit_wiring ->
        let%orzero (Side_effect_lookup_var _) = element in
        return [ Push element ; Push element ]
      | Side_effect_search_enter_wiring ->
        let%orzero (Side_effect_lookup_var _) = element in
        return []
      | Side_effect_search_without_discovery ->
        let%orzero Side_effect_search_start = element in
        return []
      | Side_effect_search_alias_analysis_init(x',acl0,ctx) ->
        let%orzero (Side_effect_lookup_var(x,patsp,patsn,acl',ctx')) =
          element
        in
        (* The following stack elements are "backwards" because they appear in
           the order in which they are pushed (similar to the other case of
           alias analysis initialization). *)
        let capture_size_5 = make_bounded_capture_size 5 in
        let capture_size_2 = make_bounded_capture_size 2 in
        let k1'' =
          [ Capture(capture_size_5)
          ; Lookup_var(x',Pattern_set.empty,Pattern_set.empty) ]
        in
        let k2'' =
          [ Capture(capture_size_2)
          ; Lookup_var(x,patsp,patsn)
          ; Jump(acl',ctx') ]
        in
        let k3'' =
          [ Alias_huh ; Jump(acl0, ctx) ]
        in
        return @@ List.map (fun x -> Push x) @@ [element] @ k3'' @ k2'' @ k1''
      | Side_effect_search_alias_analysis_resolution_1_of_4(x'') ->
        let%orzero Alias_huh = element in
        return [ Pop_dynamic_targeted (
                  Side_effect_search_alias_analysis_resolution_2_of_4(x'')) ]
      | Side_effect_search_alias_analysis_resolution_2_of_4(x'') ->
        let%orzero
          Continuation_value(Abs_filtered_value(v,patsp,patsn)) = element
        in
        [%guard (Pattern_set.is_empty patsp) ];
        [%guard (Pattern_set.is_empty patsn) ];
        return [ Pop_dynamic_targeted (
                  Side_effect_search_alias_analysis_resolution_3_of_4(x'',v)) ]
      | Side_effect_search_alias_analysis_resolution_3_of_4(x'',v1) ->
        let%orzero
          Continuation_value(Abs_filtered_value(v2,patsp,patsn)) = element
        in
        [%guard (Pattern_set.is_empty patsp) ];
        [%guard (Pattern_set.is_empty patsn) ];
        let is_alias = equal_abstract_value v1 v2 in
        return [ Pop_dynamic_targeted (
                  Side_effect_search_alias_analysis_resolution_4_of_4(
                    x'',is_alias)) ]
      | Side_effect_search_alias_analysis_resolution_4_of_4(x'',is_alias) ->
        let%orzero (Side_effect_lookup_var _) = element in
        if is_alias then
          (* 7g.ix *)
          return [ Push (Side_effect_search_escape x'') ]
        else
          (* 7g.viii *)
          return [ Push element ]
      | Side_effect_search_escape_1_of_2 ->
        let%orzero Side_effect_search_escape x'' = element in
        return [ Pop_dynamic_targeted (
                    Side_effect_search_escape_2_of_2 x'') ]
      | Side_effect_search_escape_2_of_2 x'' ->
        let%orzero Side_effect_lookup_var _ = element in
        return [ Push (Side_effect_search_escape x'') ]
      | Side_effect_search_escape_completion_1_of_4 ->
        let%orzero Side_effect_search_escape x = element in
        return [ Pop_dynamic_targeted (
                    Side_effect_search_escape_completion_2_of_4 x) ]
      | Side_effect_search_escape_completion_2_of_4 x ->
        let%orzero Side_effect_search_start = element in
        return [ Pop_dynamic_targeted (
                    Side_effect_search_escape_completion_3_of_4 x) ]
      | Side_effect_search_escape_completion_3_of_4 x ->
        let%orzero Lookup_var _ = element in
        return [ Pop_dynamic_targeted (
                    Side_effect_search_escape_completion_4_of_4 x) ]
      | Side_effect_search_escape_completion_4_of_4 x ->
        let%orzero Deref(patsp,patsn) = element in
        return [ Push (Lookup_var(x,patsp,patsn)) ]
      | Binary_operator_lookup_init(x1,x2,x3,acl1,ctx1,acl0,ctx0) ->
        let%orzero Lookup_var(x1',_,_) = element in
        [%guard (equal_var x1 x1') ];
        (* The lists below are in reverse order of their presentation in the
           formal rules because we are not directly modifying the stack;
           instead, we are pushing stack elements one at a time. *)
        let capture_size_5 = make_bounded_capture_size 5 in
        let capture_size_2 = make_bounded_capture_size 2 in
        let k1'' = [ Capture capture_size_5
                   ; Lookup_var(x2,Pattern_set.empty,Pattern_set.empty)
                   ] in
        let k2'' = [ Capture capture_size_2
                   ; Lookup_var(x3,Pattern_set.empty,Pattern_set.empty)
                   ; Jump(acl1, ctx1) ] in
        let k3'' = [ Binary_operation ; Jump(acl0,ctx0) ] in
        let k0 = [ element ] in
        return @@ List.map (fun x -> Push x) @@ k0 @ k3'' @ k2'' @ k1''
      | Unary_operator_lookup_init(x1,x2,acl0,ctx0) ->
        let%orzero Lookup_var(x1',_,_) = element in
        [%guard (equal_var x1 x1') ];
        (* The lists below are in reverse order of their presentation in the
           formal rules because we are not directly modifying the stack;
           instead, we are pushing stack elements one at a time. *)
        let capture_size_2 = make_bounded_capture_size 2 in
        let k1'' = [ Capture capture_size_2
                   ; Lookup_var(x2,Pattern_set.empty,Pattern_set.empty)
                   ] in
        let k2'' = [ Unary_operation ; Jump(acl0,ctx0) ] in
        let k0 = [ element ] in
        return @@ List.map (fun x -> Push x) @@ k0 @ k2'' @ k1''
      | Binary_operator_resolution_1_of_4(x1,op) ->
        let%orzero Binary_operation = element in
        return [ Pop_dynamic_targeted(
                    Binary_operator_resolution_2_of_4(x1,op)) ]
      | Binary_operator_resolution_2_of_4(x1,op) ->
        let%orzero
          Continuation_value(Abs_filtered_value(Abs_value_int,patsp,patsn)) =
            element
        in
        [%guard (Pattern_set.is_empty patsp) ];
        [%guard (Pattern_set.is_empty patsn) ];
        return [ Pop_dynamic_targeted(
                    Binary_operator_resolution_3_of_4(x1,op)) ]
      | Binary_operator_resolution_3_of_4(x1,op) ->
        let%orzero
          Continuation_value(Abs_filtered_value(Abs_value_int,patsp,patsn)) =
            element
        in
        [%guard (Pattern_set.is_empty patsp) ];
        [%guard (Pattern_set.is_empty patsn) ];
        return [ Pop_dynamic_targeted(
                    Binary_operator_resolution_4_of_4(x1,op)) ]
      | Binary_operator_resolution_4_of_4(x1,op) ->
        let%orzero Lookup_var(x1',patsp,patsn) = element in
        [%guard (equal_var x1 x1') ];
        let outcomes =
          match op with
          | Binary_operator_int_plus
          | Binary_operator_int_minus -> [Abs_value_int]
          | Binary_operator_int_less_than
          | Binary_operator_int_less_than_or_equal_to
          | Binary_operator_equal_to ->
            let positive_filters_have_only_empty_record =
              Pattern_set.subset patsp @@
                Pattern_set.singleton (Record_pattern Ident_map.empty)
            in
            let negative_filters_have_no_empty_record =
              not @@ Pattern_set.mem (Record_pattern Ident_map.empty) patsn
            in
            let empty_record_passes_filters =
              positive_filters_have_only_empty_record &&
              negative_filters_have_no_empty_record
            in
            if empty_record_passes_filters
            then [ Abs_value_int
                 ; Abs_value_record(Record_value(Ident_map.empty))
                 ]
            else [ Abs_value_int ]
          | Binary_operator_bool_and
          | Binary_operator_bool_or ->
            failwith "Not implemented."
        in
        let%bind v = pick_enum @@ List.enum outcomes in
        return [ Push (Continuation_value(Abs_filtered_value(
            v,Pattern_set.empty,Pattern_set.empty))) ]
      | Unary_operator_resolution_1_of_3 _
      | Unary_operator_resolution_2_of_3 _
      | Unary_operator_resolution_3_of_3 _ -> failwith "Not implemented."
    ;;
      
    let perform_untargeted_dynamic_pop element action =
      Nondeterminism_monad.enum @@
      let open Nondeterminism_monad in
      match action with
      | Do_jump ->
        let%orzero (Jump(acl1,ctx)) = element in
        return ([], Program_point_state(acl1,ctx))
      | Value_discovery_1_of_2 ->
        let%orzero (Continuation_value abs_filtered_value) = element in
        return ( [ Pop_dynamic_targeted(Value_discovery_2_of_2) ]
               , Result_state abs_filtered_value
               )
    ;;
  end;;
  
  module Ddpa_pds_reachability =
    Pds_reachability.Make(Ddpa_pds_reachability_basis)(Dph)
  ;;

  type ddpa_analysis_logging_data =
    { ddpa_logging_prefix : string
    ; ddpa_closure_steps : int
    }

  type ddpa_analysis =
    { ddpa_graph : ddpa_graph
    ; ddpa_graph_fully_closed : bool
    ; pds_reachability : Ddpa_pds_reachability.analysis
    ; ddpa_active_nodes : Annotated_clause_set.t
        (** The active nodes in the DDPA graph.  This set is maintained
            incrementally as edges are added. *)
    ; ddpa_active_non_immediate_nodes : Annotated_clause_set.t
        (** A subset of [ddpa_active_nodes] which only contains the
            non-immediate nodes.  This is useful during closure. *)
    ; ddpa_logging_data : ddpa_analysis_logging_data option
        (** Data associated with logging, if appropriate. *)
    }
  ;;

  let pp_ddpa analysis =
    Printf.sprintf
      "{\n  ddpa_graph = %s;\n  ddpa_graph_fully_closed = %s;\n  pds_reachability = %s;\n  ddpa_active_nodes = %s;\n  ddpa_active_non_immediate_nodes = %s;\n}"
      (pp_ddpa_graph analysis.ddpa_graph)
      (string_of_bool analysis.ddpa_graph_fully_closed)
      (Ddpa_pds_reachability.pp_analysis analysis.pds_reachability)
      (pp_annotated_clause_set analysis.ddpa_active_nodes)
      (pp_annotated_clause_set analysis.ddpa_active_non_immediate_nodes)
  ;;

  let get_size analysis =
    let pds_node_count, pds_edge_count = Ddpa_pds_reachability.get_size analysis.pds_reachability in
    let filter_inferrable_nodes nodes =
      nodes
      |> Annotated_clause_set.filter (
        fun node ->
          match node with
          | Enter_clause _
          | Exit_clause _ -> false
          | _ -> true
      )
    in
    Annotated_clause_set.cardinal (filter_inferrable_nodes analysis.ddpa_active_nodes),
    Annotated_clause_set.cardinal (filter_inferrable_nodes analysis.ddpa_active_non_immediate_nodes),
    analysis.ddpa_graph
    |> edges_of
    |> List.of_enum
    |> List.length,
    pds_node_count,
    pds_edge_count
  ;;

  let empty_analysis logging_prefix_opt =
    (* The initial reachability analysis should include an edge function which
       always allows discarding the bottom-of-stack marker. *)
    let empty_reachability =
      Ddpa_pds_reachability.empty ~logging_prefix:logging_prefix_opt ()
    in
    let initial_reachability =
      empty_reachability
      |> Ddpa_pds_reachability.add_edge_function
        (fun state -> Enum.singleton ([Pop Bottom_of_stack], state))
    in
    { ddpa_graph = Ddpa_graph.empty
    ; ddpa_graph_fully_closed = true
    ; pds_reachability = initial_reachability  
    ; ddpa_active_nodes = Annotated_clause_set.singleton Start_clause
    ; ddpa_active_non_immediate_nodes = Annotated_clause_set.empty
    ; ddpa_logging_data = None
    }
  ;;

  let log_ddpa_graph level analysis name_fn =
    match analysis.ddpa_logging_data with
    | None -> ()
    | Some data ->
      let name = name_fn data in
      Ddpa_graph_logger.log level name analysis.ddpa_graph
  ;;

  let add_edges edges analysis =
    let already_present =
      Enum.clone edges
      |> Enum.for_all
        (fun edge -> Ddpa_graph.has_edge edge analysis.ddpa_graph)
    in
    if already_present then (analysis,false) else
      (* ***
        First, update the PDS reachability analysis with the new edge
        information.
      *)
      let add_edge_for_reachability edge reachability =
        (* Unpack the edge *)
        let (Ddpa_edge(acl1,acl0)) = edge in
        (* Create an edge function to generate targeted dynamic pops for each
           edge. *)
        let edge_function state =
          Logger_utils.lazy_bracket_log (lazy_logger `trace)
          (fun () -> Printf.sprintf "DDPA %s edge function at state %s"
                        (pp_ddpa_edge edge) (pp_pds_state state))
          (fun edges ->
            let pp_output (actions,target) =
              String_utils.pp_tuple
                (String_utils.pp_list Ddpa_pds_reachability.pp_stack_action)
                pp_pds_state
                (actions,target)
            in
            Printf.sprintf "Generates edges: %s"
                        (String_utils.pp_list pp_output @@
                          List.of_enum @@ Enum.clone edges)) @@
          fun () ->
          let zero = Enum.empty in
          let%orzero Program_point_state(acl0',ctx) = state in
          (* TODO: There should be a way to associate each edge function with
                   its corresponding acl0 rather than using this guard. *)
          [%guard (compare_annotated_clause acl0 acl0' == 0) ];
          let open Option.Monad in
          let zero () = None in
          (* TODO: It'd be nice if we had a terser way to represent stack
                   processing operations (those that simply reorder the stack
                   without transitioning to a different node). *)
          let targeted_dynamic_pops = Enum.filter_map identity @@ List.enum
            [
              (* 1b. Value drop *)
              begin
                return (Value_drop, Program_point_state(acl0,ctx))
              end
            ;
              (* 2a. Transitivity *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(x, Abs_var_body x'))) = acl1
                in
                (* x = x' *)
                return (Variable_aliasing(x,x'),Program_point_state(acl1,ctx))
              end
            ;
              (* 2b. Stateless non-matching clause skip *)
              begin
                let%orzero (Unannotated_clause(Abs_clause(x,_))) = acl1 in
                (* x' = b *)
                return ( Stateless_nonmatching_clause_skip_1_of_2 x
                       , Program_point_state(acl1,ctx)
                       )
              end
            ;
              (* 3b. Value capture *)
              begin
                return ( Value_capture_1_of_3
                       , Program_point_state(acl0, ctx)
                       )
              end
            ;
              (* 4a. Function parameter wiring *) 
              begin
                let%orzero (Enter_clause(x,x',c)) = acl1 in
                let%orzero (Abs_clause(_,Abs_appl_body _)) = c in
                (* x =(down)c x' *)
                [%guard C.is_top c ctx];
                let ctx' = C.pop ctx in
                return (Variable_aliasing(x,x'),Program_point_state(acl1,ctx'))
              end
            ;
              (* 4b. Function return wiring start *)
              begin
                let%orzero (Exit_clause(x,_,c)) = acl1 in
                let%orzero (Abs_clause(_,Abs_appl_body(x2'',x3''))) = c in
                (* x =(up)c _ (for functions) *)
                return ( Function_call_flow_validation(x2'',x3'',acl0,Unannotated_clause(c),ctx,x)
                       , Program_point_state(Unannotated_clause(c),ctx)
                       )
              end
            ;
              (* 4c. Function return wiring finish *)
              begin
                let%orzero (Exit_clause(x,x',c)) = acl1 in
                let%orzero (Abs_clause(_,Abs_appl_body _)) = c in
                (* x =(up)c x' *)
                let ctx' = C.push c ctx in
                return ( Function_call_flow_validation_resolution_1_of_2(x,x')
                       , Program_point_state(acl1,ctx')
                       )
              end
            ;
              (* 4d. Function non-local wiring *)
              begin
                let%orzero (Enter_clause(x'',_,c)) = acl1 in
                let%orzero (Abs_clause(_,Abs_appl_body(x2'',_))) = c in
                (* x'' =(down)c x' *)
                [%guard C.is_top c ctx];
                let ctx' = C.pop ctx in
                return ( Function_closure_lookup(x'',x2'')
                       , Program_point_state(acl1,ctx')
                       )
              end
            ;
              (* 5a, 5b, and 5e. Conditional entrance wiring *)
              begin
                (* This block represents *all* conditional closure handling on
                   the entering side. *)
                let%orzero (Enter_clause(x',x1,c)) = acl1 in
                let%orzero
                  (Abs_clause(_,Abs_conditional_body(x1',p,f1,_))) = c
                in
                (* TODO: this guard should always succeed; make an assertion *)
                [%guard (equal_var x1 x1')];
                let Abs_function_value(f1x,_) = f1 in
                (* x'' =(down)c x' for conditionals *)
                let closure_for_positive_path = equal_var f1x x' in
                return ( Conditional_closure_lookup
                          (x',x1,p,closure_for_positive_path)
                       , Program_point_state(acl1,ctx)
                       )
              end
            ;
              (* 5c, 5d. Conditional return wiring *)
              begin
                let%orzero (Exit_clause(x,x',c)) = acl1 in
                let%orzero
                  (Abs_clause(_,Abs_conditional_body(x1,pat,f1,_))) = c
                in
                (* x =(up) x' for conditionals *)
                let Abs_function_value(_,Abs_expr(cls)) = f1 in
                let f1ret = rv cls in
                let then_branch = equal_var f1ret x' in
                return ( Conditional_subject_validation(
                            x,x',x1,pat,then_branch,acl1,ctx)
                       , Program_point_state(Unannotated_clause(c),ctx)
                       )
              end
            ;
              (* 6a. Record destruction *)
              begin
                let%orzero
                  (Unannotated_clause(
                    Abs_clause(x,Abs_projection_body(x',l)))) = acl1
                in
                (* x = x'.l *)
                return ( Record_projection_lookup(x,x',l)
                       , Program_point_state(acl1,ctx)
                       )
              end
            ;
              (* 6b. Record projection *)
              begin
                return ( Record_projection_1_of_2
                       , Program_point_state(acl0,ctx)
                       )
              end
            ;
              (* 7a. Function filter validation *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(
                      x,Abs_value_body(Abs_value_function(v))))) = acl1
                in
                (* x = f *)
                return ( Function_filter_validation(x,v)
                       , Program_point_state(acl0,ctx)
                       )
              end
            ;
              (* 7b. Record validation *)
              begin
                let%orzero
                  (Unannotated_clause(
                    Abs_clause(x,Abs_value_body(Abs_value_record(r))))) = acl1
                in
                (* x = r *)
                let target_state = Program_point_state(acl0,ctx) in
                return ( Record_filter_validation(
                           x,r,acl1,ctx,acl0,ctx)
                       , target_state
                       )
              end
            ;
              (* 7c. Integer filter validation *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(
                      x,Abs_value_body(Abs_value_int)))) = acl1
                in
                (* x = int *)
                return ( Int_filter_validation(x)
                       , Program_point_state(acl1,ctx)
                       )
              end
            ;
              (* 7d, 7e. Boolean filter validation *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(
                      x,Abs_value_body(Abs_value_bool(b))))) = acl1
                in
                (* x = true OR x = false *)
                return ( Bool_filter_validation(x,b)
                       , Program_point_state(acl1,ctx)
                       )
              end
            ;
              (* 8a. Assignment result *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(x, Abs_update_body _))) = acl1
                in
                (* x = x' <- x'' -- produce {} for x *)
                return ( Empty_record_value_discovery x
                       , Program_point_state(acl1,ctx)
                       )
              end
            ;
              (* 8b. Dereference lookup *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(x, Abs_deref_body(x')))) = acl1
                in
                (* x = !x' *)
                return ( Dereference_lookup(x,x')
                       , Program_point_state(acl1,ctx)
                       )
              end
            ;
              (* 8c. Cell validation *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(
                      x,Abs_value_body(Abs_value_ref(cell))))) = acl1
                in
                (* x = ref x' *)
                return ( Cell_filter_validation(x,cell)
                       , Program_point_state(acl0,ctx)
                       )
              end
            ;
              (* 8d. Cell dereference *)
              begin
                return ( Cell_dereference_1_of_2
                       , Program_point_state(acl0, ctx) )                
              end
            ;
              (* 9a. Cell update alias analysis initialization *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(
                      _, Abs_update_body(x',_)))) = acl1
                in
                (* x''' = x' <- x'' *)
                let source_state = Program_point_state(acl1,ctx) in
                let target_state = Program_point_state(acl0,ctx) in
                return ( Cell_update_alias_analysis_init_1_of_2(
                          x',source_state,target_state)
                       , Program_point_state(acl0, ctx) )
              end
            ; (* 9b,9c. Alias resolution *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(
                      _, Abs_update_body(_,x'')))) = acl1
                in
                (* x''' = x' <- x'' *)
                return ( Alias_analysis_resolution_1_of_5(x'')
                       , Program_point_state(acl1, ctx) )
              end
            ; (* 10a. Stateful non-side-effecting clause skip *)
              begin
                let%orzero (Unannotated_clause(Abs_clause(x,b))) = acl1 in
                [% guard (is_immediate acl1) ];
                [% guard (b |>
                    (function
                      | Abs_update_body _ -> false
                      | _ -> true)) ];
                (* x' = b *)
                return ( Nonsideeffecting_nonmatching_clause_skip x
                       , Program_point_state(acl1,ctx)
                       )
              end
            ; (* 10b. Side-effect search initialization *)
              begin
                let%orzero (Exit_clause(x'',_,c)) = acl1 in
                (* x'' =(up)c x' *)
                let%bind ctx' =
                  match c with
                  | Abs_clause(_,Abs_appl_body _) -> return @@ C.push c ctx
                  | Abs_clause(_,Abs_conditional_body _) -> return ctx
                  | _ -> zero ()
                in
                return ( Side_effect_search_init_1_of_2(x'',acl0,ctx)
                       , Program_point_state(acl1,ctx') )
              end
            ; (* 10c. Side-effect search non-matching clause skip *)
              begin
                let%orzero (Unannotated_clause(Abs_clause(_,b))) = acl1 in
                [% guard (is_immediate acl1) ];
                [% guard (b |>
                    (function
                      | Abs_update_body _ -> false
                      | _ -> true)) ];
                (* x' = b *)
                return ( Side_effect_search_nonmatching_clause_skip
                       , Program_point_state(acl1,ctx) )
              end
            ; (* 10d. Side-effect search exit wiring node *)
              begin
                let%orzero (Exit_clause(_,_,c)) = acl1 in
                (* x'' =(up)c x' *)
                let%bind ctx' =
                  match c with
                  | Abs_clause(_,Abs_appl_body _) -> return @@ C.push c ctx
                  | Abs_clause(_,Abs_conditional_body _) -> return ctx
                  | _ -> zero ()
                in
                return ( Side_effect_search_exit_wiring
                       , Program_point_state(acl1,ctx') )
              end
            ; (* 10e. Side-effect search enter wiring node *)
              begin
                let%orzero (Enter_clause(_,_,c)) = acl1 in
                (* x'' =(down)c x' *)
                let%bind ctx' =
                  match c with
                  | Abs_clause(_,Abs_appl_body _) -> return @@ C.pop ctx
                  | Abs_clause(_,Abs_conditional_body _) -> return ctx
                  | _ -> zero ()
                in
                return ( Side_effect_search_enter_wiring
                       , Program_point_state(acl1,ctx') )
              end
              (* FIXME: why does this clause kill performance? *)
            ; (* 10f. Side-effect search without discovery *)
              begin
                return ( Side_effect_search_without_discovery
                       , Program_point_state(acl0,ctx) )
              end
            ; (* 10g. Side-effect search alias analysis initialization *)
              begin
                let%orzero (Unannotated_clause(
                              Abs_clause(_,Abs_update_body(x',_)))) = acl1
                in
                return ( Side_effect_search_alias_analysis_init(x',acl0,ctx)
                       , Program_point_state(acl1,ctx) )
              end
            ; (* 10h,10i. Side-effect search alias analysis resolution *)
              begin
                let%orzero (Unannotated_clause(
                              Abs_clause(_,Abs_update_body(_,x'')))) = acl1
                in
                return ( Side_effect_search_alias_analysis_resolution_1_of_4(
                            x'')
                       , Program_point_state(acl1,ctx) )
              end
            ; (* 10j. Side-effect search escape *)
              begin
                return ( Side_effect_search_escape_1_of_2
                       , Program_point_state(acl0,ctx) )
              end
            ; (* 10k. Side-effect search escape completion *)
              begin
                return ( Side_effect_search_escape_completion_1_of_4
                       , Program_point_state(acl0,ctx) )
              end
            ; (* 11a. Binary operation operand lookup *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(x1,
                            Abs_binary_operation_body(x2,_,x3)))) = acl1
                in
                (* x1 = x2 op x3 *)
                return ( Binary_operator_lookup_init(
                            x1,x2,x3,acl1,ctx,acl0,ctx)
                       , Program_point_state(acl1,ctx)
                       )
              end
            ; (* 11b. Unary operation operand lookup *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(x1,
                            Abs_unary_operation_body(_,x2)))) = acl1
                in
                (* x1 = op x2 *)
                return ( Unary_operator_lookup_init(
                            x1,x2,acl0,ctx)
                       , Program_point_state(acl1,ctx)
                       )
              end
            ; (* 12a,12b,12c,13a,13b,13c,13d,13e,13f,13g,13h,13i,13j,13k,13l. Binary operator resolution *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(x1,
                            Abs_binary_operation_body(_,op,_)))) = acl1
                in
                (* x1 = x2 op x3 *)
                return ( Binary_operator_resolution_1_of_4(x1,op)
                       , Program_point_state(acl0,ctx)
                       )
              end
            ; (* 13m,13n. Unary operator resolution *)
              begin
                let%orzero
                  (Unannotated_clause(Abs_clause(x1,
                            Abs_unary_operation_body(op,_)))) = acl1
                in
                (* x1 = op x2 *)
                return ( Unary_operator_resolution_1_of_3(x1,op)
                       , Program_point_state(acl0,ctx)
                       )
              end
            ]
          in
          targeted_dynamic_pops
          |> Enum.map
              (fun (action,state) -> ([Pop_dynamic_targeted(action)], state))
        in
        (* Create another function to handle the untargeted dynamic pops. *)
        let untargeted_dynamic_pop_action_function state =
          let zero = Enum.empty in
          let%orzero Program_point_state(acl0',_) = state in
          (* TODO: There should be a way to associate each action function with
                   its corresponding acl0 rather than using this guard. *)
          [%guard (compare_annotated_clause acl0 acl0' == 0)];
          let open Option.Monad in
          let untargeted_dynamic_pops = Enum.filter_map identity @@ List.enum
            [
              (* 1a. Value discovery. *)
              begin
                return @@ Value_discovery_1_of_2
              end
            ;
              (* 3a. Jump. *)
              begin
                return @@ Do_jump
              end
            ]
          in
          untargeted_dynamic_pops
        in
        (* Put it all together with the reachability parameter to produce the
           new reachability structure. *)
        reachability
        |> Ddpa_pds_reachability.add_edge_function edge_function
        |> Ddpa_pds_reachability.add_untargeted_dynamic_pop_action_function
            untargeted_dynamic_pop_action_function
      in
      let pds_reachability' =
        Enum.clone edges
        |> Enum.fold (flip add_edge_for_reachability) analysis.pds_reachability
      in
      (* ***
        Next, add the edge to the DDPA graph.
      *)
      let ddpa_graph' =
        Enum.clone edges
        |> Enum.fold (flip Ddpa_graph.add_edge) analysis.ddpa_graph 
      in
      (* ***
        Now, perform closure over the active node set.  This function uses a
        list of enumerations of nodes to explore.  This reduces the cost of
        managing the work queue.
      *)
      let rec find_new_active_nodes from_acls_enums results_so_far =
        match from_acls_enums with
        | [] -> results_so_far
        | from_acls_enum::from_acls_enums' ->
          if Enum.is_empty from_acls_enum
          then find_new_active_nodes from_acls_enums' results_so_far
          else
            let from_acl = Enum.get_exn from_acls_enum in
            if Annotated_clause_set.mem from_acl analysis.ddpa_active_nodes ||
               Annotated_clause_set.mem from_acl results_so_far
            then find_new_active_nodes from_acls_enums results_so_far
            else
              let results_so_far' =
                Annotated_clause_set.add from_acl results_so_far
              in
              let from_here = ddpa_graph' |> Ddpa_graph.succs from_acl in
              find_new_active_nodes (from_here::from_acls_enums) results_so_far'
      in
      let (ddpa_active_nodes',ddpa_active_non_immediate_nodes') =
        let new_active_root_nodes =
          Enum.clone edges
          |> Enum.filter_map
            (fun (Ddpa_edge(acl_left,acl_right)) ->
              if Annotated_clause_set.mem acl_left analysis.ddpa_active_nodes
              then Some acl_right
              else None)
          |> Enum.filter
            (fun acl ->
              not @@ Annotated_clause_set.mem acl analysis.ddpa_active_nodes)
        in
        let new_active_nodes =
          find_new_active_nodes [new_active_root_nodes]
            Annotated_clause_set.empty
        in
        ( Annotated_clause_set.union analysis.ddpa_active_nodes
            new_active_nodes
        , Annotated_clause_set.union analysis.ddpa_active_non_immediate_nodes
            ( new_active_nodes |> Annotated_clause_set.filter
                (not % is_annotated_clause_immediate) )
        )
      in
      (
        { ddpa_graph = ddpa_graph'
        ; ddpa_graph_fully_closed = false
        ; pds_reachability =  pds_reachability'
        ; ddpa_active_nodes = ddpa_active_nodes'
        ; ddpa_active_non_immediate_nodes = ddpa_active_non_immediate_nodes'
        ; ddpa_logging_data = analysis.ddpa_logging_data
        }
      , true
      )
  ;;

  let create_initial_analysis ?logging_prefix:(logging_prefix=None) e =
    let Abs_expr(cls) = lift_expr e in
    (* Put the annotated clauses together. *)
    let acls =
      List.enum cls
      |> Enum.map (fun x -> Unannotated_clause x)
      |> Enum.append (Enum.singleton Start_clause)
      |> flip Enum.append (Enum.singleton End_clause)
    in
    (* For each pair, produce a DDPA edge. *)
    let rec mk_edges acls' =
      match Enum.get acls' with
      | None -> []
      | Some acl1 ->
        match Enum.peek acls' with
        | None -> []
        | Some acl2 ->
          Ddpa_edge(acl1,acl2) :: mk_edges acls'
    in
    let edges = List.enum @@ mk_edges acls in
    let empty_analysis' =
      match logging_prefix with
      | None -> empty_analysis None
      | Some prefix ->
        { (empty_analysis @@ Some prefix) with
          ddpa_logging_data = Some
            { ddpa_closure_steps = 0
            ; ddpa_logging_prefix = prefix
            }
        }
    in
    let analysis = fst @@ add_edges edges empty_analysis' in
    logger `trace "Created initial analysis";
    log_ddpa_graph Ddpa_graph_logger.Ddpa_log_all analysis
      (fun data ->
        Ddpa_graph_logger.Ddpa_graph_name_initial data.ddpa_logging_prefix);
    analysis
  ;;

  let restricted_values_of_variable x acl ctx patsp patsn analysis =
    Logger_utils.lazy_bracket_log (lazy_logger `trace)
      (fun () ->
        Printf.sprintf "Determining values of variable %s at position %s%s"
          (pp_var x) (pp_annotated_clause acl) @@
          if Pattern_set.is_empty patsp && Pattern_set.is_empty patsn
          then ""
          else
            Printf.sprintf " with pattern sets %s and %s"
              (pp_pattern_set patsp) (pp_pattern_set patsn)
          )
      (fun (values, _) ->
        String_utils.concat_sep_delim "{" "}" ", " @@
          Enum.map pp_abs_filtered_value @@ Enum.clone values)
    @@ fun () ->
    let start_state = Program_point_state(acl,ctx) in
    let start_actions =
      [Push Bottom_of_stack; Push (Lookup_var(x,patsp,patsn))]
    in
    let reachability = analysis.pds_reachability in
    let reachability' =
      reachability
      |> Ddpa_pds_reachability.add_start_state start_state start_actions
    in
    let analysis' = { analysis with pds_reachability = reachability' } in
    let values =
      reachability'
      |> Ddpa_pds_reachability.get_reachable_states start_state start_actions
      |> Enum.filter_map
        (function
          | Program_point_state _ -> None
          | Result_state v -> Some v)
    in
    (values, analysis')
  ;;

  let values_of_variable x acl analysis =
    let (values, analysis') =
      restricted_values_of_variable x acl C.empty
        Pattern_set.empty Pattern_set.empty analysis
    in
    (Abs_filtered_value_set.of_enum values, analysis')
  ;;

  let contextual_values_of_variable x acl ctx analysis =
    let (values, analysis') =
      restricted_values_of_variable x acl ctx
        Pattern_set.empty Pattern_set.empty analysis
    in
    (Abs_filtered_value_set.of_enum values, analysis')
  ;;

  let wire site_cl func x1 x2 graph =
    let site_acl = Unannotated_clause(site_cl) in
    let Abs_function_value(x0, Abs_expr(body)) = func in
    let wire_in_acl = Enter_clause(x0,x1,site_cl) in
    let wire_out_acl = Exit_clause(x2,rv body,site_cl) in
    let pred_edges =
      Ddpa_graph.preds site_acl graph
      |> Enum.map (fun acl' -> Ddpa_edge(acl',wire_in_acl))
    in
    let succ_edges =
      Ddpa_graph.succs site_acl graph
      |> Enum.map (fun acl' -> Ddpa_edge(wire_out_acl,acl'))
    in
    let inner_edges =
      List.enum body
      |> Enum.map (fun cl -> Unannotated_clause(cl))
      |> Enum.append (Enum.singleton wire_in_acl)
      |> flip Enum.append (Enum.singleton wire_out_acl)
      |> Utils.pairwise_enum_fold
          (fun acl1 acl2 -> Ddpa_edge(acl1,acl2))
    in
    Enum.append pred_edges @@ Enum.append inner_edges succ_edges
  ;;

  let perform_closure_steps analysis =
    begin
      match analysis.ddpa_logging_data with
      | None -> lazy_logger `trace (fun () -> "Performing closure step")
      | Some data -> lazy_logger `trace (fun () ->
          (Printf.sprintf "Performing closure step %d"
            (data.ddpa_closure_steps+1)));
    end;
    (* We need to do work on each of the active, non-immediate nodes.  This
       process includes variable lookups, which may result in additional work
       being done; as a result, each closure step might change the underlying
       graph.  We'll keep the analysis in a ref so that, whenever work is done
       which produces a new analysis, we can just update the ref. *)
    let analysis_ref = ref analysis in
    let new_edges_enum = Nondeterminism_monad.enum
      (
        let open Nondeterminism_monad in
        let%bind acl =
          pick_enum @@
            Annotated_clause_set.enum analysis.ddpa_active_non_immediate_nodes
        in
        let has_values x patsp patsn =
          let (values,analysis') =
            restricted_values_of_variable
              x acl C.empty patsp patsn !analysis_ref
          in
          analysis_ref := analysis';
          not @@ Enum.is_empty values
        in
        match acl with
        | Unannotated_clause(Abs_clause(x1,Abs_appl_body(x2,x3)) as cl) ->
          lazy_logger `trace
            (fun () ->
              Printf.sprintf "Considering application closure for clause %s"
                (pp_abstract_clause cl));
          (* Make sure that a value shows up to the argument. *)
          [%guard has_values x3 Pattern_set.empty Pattern_set.empty];
          (* Get each of the function values. *)
          let (x2_values,analysis_2) =
            restricted_values_of_variable
              x2 acl C.empty Pattern_set.empty Pattern_set.empty !analysis_ref
          in
          analysis_ref := analysis_2;
          let%bind x2_value = pick_enum x2_values in
          let%orzero
            Abs_filtered_value(Abs_value_function(fn),_,_) = x2_value
          in
          (* Wire each one in. *)
          return @@ wire cl fn x3 x1 analysis_2.ddpa_graph
        | Unannotated_clause(
            Abs_clause(x1,Abs_conditional_body(x2,p,f1,f2)) as cl) ->
          lazy_logger `trace
            (fun () ->
              Printf.sprintf "Considering conditional closure for clause %s"
                (pp_abstract_clause cl));
          (* We have two functions we may wish to wire: f1 (if x2 has values
             which match the pattern) and f2 (if x2 has values which antimatch
             the pattern). *)
          [ (Pattern_set.singleton p, Pattern_set.empty, f1)
          ; (Pattern_set.empty, Pattern_set.singleton p, f2)
          ]
            |> List.enum
            |> Enum.filter_map
              (fun (patsp,patsn,f) ->
                if has_values x2 patsp patsn then Some f else None)
            |> Enum.map (fun f -> wire cl f x2 x1 (!analysis_ref).ddpa_graph)
            |> Nondeterminism_monad.pick_enum
        | _ ->
          raise @@ Utils.Invariant_failure
            "Unhandled clause in perform_closure_steps"
      )
        |> Enum.concat
    in
    (* Due to the stateful effects of computing the new edges, we're going to
       want to pull on the entire enumeration before we start looking at the
       analysis. *)
    let new_edges_list = List.of_enum new_edges_enum in
    (* Now we want to add all of the new edges.  If there are any new ones, we
       need to know about it. *)
    let (analysis',any_new) =
      add_edges (List.enum new_edges_list) !analysis_ref
    in
    let ddpa_logging_data' =
      match analysis'.ddpa_logging_data with
      | None -> None
      | Some data ->
        Some { data with ddpa_closure_steps = data.ddpa_closure_steps+1 }
    in
    let result = 
      { analysis' with
        ddpa_graph_fully_closed = not any_new;
        ddpa_logging_data = ddpa_logging_data'
      }
    in
    begin
      match result.ddpa_logging_data with
      | None -> logger `trace "Completed closure step"
      | Some data -> lazy_logger `trace
          (fun () -> Printf.sprintf "Completed closure step %d"
            (data.ddpa_closure_steps));
    end;
    log_ddpa_graph Ddpa_graph_logger.Ddpa_log_all analysis
      (fun data -> Ddpa_graph_logger.Ddpa_graph_name_intermediate(
          data.ddpa_logging_prefix, data.ddpa_closure_steps));
    result
  ;;
  
  let is_fully_closed analysis = analysis.ddpa_graph_fully_closed;;
  
  let rec perform_full_closure analysis =
    if is_fully_closed analysis
    then
      begin
        logger `trace "Closure complete.";
        log_ddpa_graph Ddpa_graph_logger.Ddpa_log_result analysis
          (fun data ->
            Ddpa_graph_logger.Ddpa_graph_name_closed(data.ddpa_logging_prefix));
        analysis
      end
    else
      begin
        perform_full_closure @@ perform_closure_steps analysis
      end
  ;;

  let set_pdr_logger_level level =
    Ddpa_pds_reachability.set_logging_level level
  ;;

  let get_pdr_logger_level () =
    Ddpa_pds_reachability.get_logging_level ()
  ;;
end;;
