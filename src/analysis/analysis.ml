(**
  This module gives an implementation of the DDPA analysis.  It is parametric
  in the choice of context stack.
*)

open Batteries;;

open Analysis_context_stack;;
open Ast;;
open Ast_pretty;;
open Ddpa_graph;;
open Nondeterminism;;
open Pds_reachability_types_stack;;

let logger = Logger_utils.make_logger "Analysis";;
let lazy_logger = Logger_utils.make_lazy_logger "Analysis";;

module Pattern_ord =
struct
  type t = pattern
  let compare = compare_pattern
end;;

module Pattern_set = Set.Make(Pattern_ord);;

let pp_pattern_set pats =
  String_utils.concat_sep_delim "{" "}" ", " @@ Enum.map pretty_pattern @@
    Pattern_set.enum pats
;;

module type Analysis_sig =
sig
  (** The type of the DDPA analysis generated by the module. *)
  type ddpa_analysis
  
  (** The initial, unclosed analysis derived from an expression. *)
  val create_initial_analysis :
    ?logging_prefix:string option -> expr -> ddpa_analysis
  
  (** Pretty-prints a DDPA structure. *)
  val pp_ddpa : ddpa_analysis -> string
  
  (** Performs a series of closure steps on an analysis.  This is not guaranteed
      to complete closure; however, it will make progress as long as the
      argument is not fully closed. *)
  val perform_closure_steps : ddpa_analysis -> ddpa_analysis
  
  (** Determines if an analysis is fully closed. *)
  val is_fully_closed : ddpa_analysis -> bool
  
  (** Fully closes an analysis. *)
  val perform_full_closure : ddpa_analysis -> ddpa_analysis
  
  (** Determines the values at a given position of the provided variable in the
      given analysis.  This is an approximation -- false positives may arise --
      but it is guaranteed to be conservative if the analysis is fully closed.
      The returned analysis contains a cache structure to accelerate answering
      of this question in the future. *)
  val values_of_variable :
    annotated_clause -> var -> ddpa_analysis -> Abs_value_set.t * ddpa_analysis
    
  (** Sets the logging level for the PDS reachability analysis used by this
      module. *)
  val set_pdr_logger_level :
    Pds_reachability_logger_utils.pds_reachability_logger_level -> unit
    
  (** Gets the logging level for the PDS reachability analysis used by this
      module. *)
  val get_pdr_logger_level :
    unit -> Pds_reachability_logger_utils.pds_reachability_logger_level
end;;

(**
  A functor which constructs a DDPA analysis module.
*)
module Make(C : Context_stack)
  : Analysis_sig =
struct
  let negative_pattern_set_selection record_type pattern_set =
    let (Record_value m) = record_type in
    let record_labels = Ident_set.of_enum @@ Ident_map.keys m in
    let relevant_patterns = pattern_set
      |> Pattern_set.enum
      |> Enum.filter
          (fun (Record_pattern m') ->
            Ident_set.subset (Ident_set.of_enum @@ Ident_map.keys m')
              record_labels)
    in
    (* This function selects a single label from a given pattern and constructs
       a pattern from it. *)
    let pick_pattern (Record_pattern m') =
      let open Nondeterminism_monad in
      let%bind (k,v) = pick_enum @@ Ident_map.enum m' in
      return @@ Record_pattern(Ident_map.singleton k v)
    in
    let open Nondeterminism_monad in
    let%bind selected_patterns = 
      Nondeterminism_monad.mapM pick_pattern relevant_patterns
    in
    return @@ Pattern_set.of_enum selected_patterns
  ;;

  let pattern_projection (Record_pattern m) label =
    try
      Some (Ident_map.find label m)
    with
    | Not_found -> None
  ;;

  let pattern_set_projection set label =
    set
    |> Pattern_set.enum
    |> Enum.map (flip pattern_projection label)
    |> Enum.filter_map identity
    |> Pattern_set.of_enum
  ;;

  let labels_in_record (Record_value m) =
    Ident_set.of_enum @@ Ident_map.keys m
  ;;

  let labels_in_pattern (Record_pattern m) =
    Ident_set.of_enum @@ Ident_map.keys m
  ;;

  let labels_in_pattern_set set =
    set
    |> Pattern_set.enum
    |> Enum.map labels_in_pattern
    |> Enum.fold Ident_set.union Ident_set.empty
  ;;
  
  type pds_continuation =
    | Bottom_of_stack
    | Lookup_var of var * Pattern_set.t * Pattern_set.t
    | Project of ident * Pattern_set.t * Pattern_set.t
    | Jump of annotated_clause * C.t
    | Deref of Pattern_set.t * Pattern_set.t
    | Capture
    | Continuation_value of abstract_value
    | Alias_huh
    [@@deriving ord]
  ;;

  module Pds_continuation_ord =
  struct
    type t = pds_continuation
    let compare = compare_pds_continuation
  end;;

  let pp_pds_continuation = function
    | Bottom_of_stack ->
      "Bottom_of_stack"
    | Lookup_var(x,patsp,patsn) ->
      Printf.sprintf "%s(%s/%s)"
        (pretty_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Project(i,patsp,patsn) ->
      Printf.sprintf ".%s(%s/%s)"
        (pretty_ident i) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Jump(acl,ctx) ->
      Printf.sprintf "Jump(%s,%s)" (pp_annotated_clause acl) (C.pretty ctx)
    | Deref(patsp,patsn) ->
      Printf.sprintf "!(%s,%s)" (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Capture -> "Capture"
    | Continuation_value v -> pp_abstract_value v
    | Alias_huh -> "Alias?"
  ;;

  let ppa_pds_continuation = function
    | Bottom_of_stack -> "Bot"
    | Lookup_var(x,patsp,patsn) ->
      if Pattern_set.is_empty patsp && Pattern_set.is_empty patsn
      then pretty_var x
      else Printf.sprintf "%s(%s/%s)"
              (pretty_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Project(i,patsp,patsn) ->
      if Pattern_set.is_empty patsp && Pattern_set.is_empty patsn
      then Printf.sprintf ".%s" (pretty_ident i)
      else Printf.sprintf ".%s(%s/%s)"
              (pretty_ident i) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Jump(acl,ctx) ->
      Printf.sprintf "Jump(%s,%s)"
        (ppa_annotated_clause acl) (C.pretty_abbrv ctx)
    | Deref(patsp,patsn) ->
      Printf.sprintf "!(%s,%s)" (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Capture -> "Capture"
    | Continuation_value v -> pp_abstract_value v
    | Alias_huh -> "Alias?"
  ;;

  type pds_state =
    Pds_state of annotated_clause * C.t
    [@@deriving ord]
  ;;

  let pp_pds_state (Pds_state(acl,ctx)) =
    Printf.sprintf "(%s @ %s)"
      (pp_annotated_clause acl) (C.pretty ctx)
  ;;

  let ppa_pds_state (Pds_state(acl,ctx)) =
    Printf.sprintf "(%s @ %s)"
      (ppa_annotated_clause acl) (C.pretty_abbrv ctx)
  ;;

  module Pds_state_ord =
  struct
    type t = pds_state
    let compare = compare_pds_state
  end;;

  module Ddpa_pds_reachability_basis = 
  struct
    type state = pds_state
    type stack_element = pds_continuation
    module State_ord = Pds_state_ord
    module Stack_element_ord = Pds_continuation_ord
    let pp_state = pp_pds_state
    let pp_stack_element = pp_pds_continuation
    let ppa_state = ppa_pds_state
    let ppa_stack_element = ppa_pds_continuation
  end
  
  type pds_targeted_dynamic_pop_action =
    | Variable_discovery of var
      (** Represents the rule that, upon discovering the variable for which we
          are looking, we pop that variable from the stack and move on.  The
          payload is the variable which we could discover here. *)
    | Variable_aliasing of var * var
      (** Represents variable aliasing, as in "x = y".  The first variable
          is the one being declared; the second variable is the one being
          used.  This pop action is used for every rule which performs basic
          x-to-y aliasing regardless of whether the clause in question is
          annotated. *)
    | Stateless_nonmatching_clause_skip_1_of_2 of var
      (** Represents the first step of skipping a non-matching clause while
          stateless.  If we are searching for x, we may skip over any clause of
          the form x'' = b (even if b is non-immediate) as long as we are not
          trying to dereference x''.  The first step of this process captures
          the variable which we should *not* match.  The second step carries
          the variable continuation and confirms the absence of a dereference
          continuation. *)
    | Stateless_nonmatching_clause_skip_2_of_2 of pds_continuation
      (** The second step of skipping a non-matching clause while stateless. *)
    | Function_closure_lookup of var * var
      (** Represents a function closure lookup.  The first variable is the
          parameter of the function; the second variable is the function itself.
          If the lookup variable does not match the parameter, then this lookup
          is for a non-local and we must search for the function's definition
          first. *)
    | Conditional_closure_lookup of var * pattern * bool
      (** Represents a conditional closure lookup.  If the variable matches our
          lookup target, then we've learned something about it: that it matches
          the pattern (if the boolean is true) or that it does not (if the
          boolean is false).  If the variable does not match our lookup target,
          we have learned nothing. *)
    | Record_projection_lookup of var * var * ident
      (** Represents a record projection.  If the first variable matches our
          lookup target, then we've discovered that we are looking up the
          projection of the ident label from a record stored in the second
          variable. *)
    | Record_construction_lookup_1_of_2 of
        pds_state * pds_state * var * record_value
      (** Represents lookup as applied to a record construction node.  If the
          variable matches our lookup variable, then we've found our value and
          should take action.  The particular action to take depends upon
          whether the next stack element is a projection (in which case we
          should do the projection) or if it is not (in which case we should
          just validate the record filters).  The PDS states are the source and
          target of the operation (respectively) and are carried here for
          convenience. *)
      (* FIXME: Shouldn't rule 1b specifically exclude variables from which we
                are projecting values? *)
      (* FIXME: There's no good way for the caller to get at the filters which
                applied to the record under this model, right?  That seems a
                shame.  Perhaps we can use the start-of-stack element to
                move to a dedicated answer state when we pop the last
                element? *)
    | Record_construction_lookup_2_of_2 of
        pds_state * pds_state * var * record_value *
          Pattern_set.t * Pattern_set.t
      (** The second step of record construction lookup. *)
    | Function_filter_validation of var
      (** Represents the validation of filters for a function under lookup.  If
          the variable matches our lookup variable, any negative filters are
          admissible and can be erased (although positive filters cannot). *)
    (* TODO *)
    [@@deriving ord]
  ;;
  
  let pp_pds_targeted_dynamic_pop_action action =
    match action with
    | Variable_discovery x ->
      Printf.sprintf "Variable_discovery(%s)" (pretty_var x)
    | Variable_aliasing(x,x') ->
      Printf.sprintf "Variable_aliasing(%s,%s)" (pretty_var x) (pretty_var x')
    | Stateless_nonmatching_clause_skip_1_of_2(x) ->
      Printf.sprintf "Stateless_nonmatching_clause_skip_1_of_2(%s)"
        (pretty_var x)
    | Stateless_nonmatching_clause_skip_2_of_2(k) ->
      Printf.sprintf "Stateless_nonmatching_clause_skip_2_of_2(%s)"
        (pp_pds_continuation k)
    | Function_closure_lookup(x'',xf) ->
      Printf.sprintf "Function_closure_lookup(%s,%s)"
        (pretty_var x'') (pretty_var xf)
    | Conditional_closure_lookup(x,p,b) ->
      Printf.sprintf "Conditional_closure_lookup(%s,%s,%b)"
        (pretty_var x) (pretty_pattern p) b
    | Record_projection_lookup(x,x',l) ->
      Printf.sprintf "Record_projection_lookup(%s,%s,%s)"
        (pretty_var x) (pretty_var x') (pretty_ident l)
    | Record_construction_lookup_1_of_2(source_state,target_state,x,r) ->
      Printf.sprintf "Record_construction_lookup_1_of_2(%s,%s,%s,%s)"
        (pp_pds_state source_state) (pp_pds_state target_state) (pretty_var x)
          (pretty_record_value r)
    | Record_construction_lookup_2_of_2(
        source_state,target_state,x,r,patsp,patsn) ->
      Printf.sprintf "Record_construction_lookup_2_of_2(%s,%s,%s,%s,%s,%s)"
        (pp_pds_state source_state) (pp_pds_state target_state) (pretty_var x)
          (pretty_record_value r) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Function_filter_validation(x) ->
      Printf.sprintf "Function_filter_validation(%s)" (pretty_var x)
  ;;

  let ppa_pds_targeted_dynamic_pop_action action =
    match action with
    | Variable_discovery x ->
      Printf.sprintf "VDisc(%s)" (pretty_var x)
    | Variable_aliasing(x,x') ->
      Printf.sprintf "VAlias(%s,%s)" (pretty_var x) (pretty_var x')
    | Stateless_nonmatching_clause_skip_1_of_2(x) ->
      Printf.sprintf "SNMCS1(%s)"
        (pretty_var x)
    | Stateless_nonmatching_clause_skip_2_of_2(k) ->
      Printf.sprintf "SNMCS2(%s)"
        (ppa_pds_continuation k)
    | Function_closure_lookup(x'',xf) ->
      Printf.sprintf "FunCL(%s,%s)"
        (pretty_var x'') (pretty_var xf)
    | Conditional_closure_lookup(x,p,b) ->
      Printf.sprintf "CondCL(%s,%s,%b)"
        (pretty_var x) (pretty_pattern p) b
    | Record_projection_lookup(x,x',l) ->
      Printf.sprintf "RProjL(%s,%s,%s)"
        (pretty_var x) (pretty_var x') (pretty_ident l)
    | Record_construction_lookup_1_of_2(source_state,target_state,x,r) ->
      Printf.sprintf "RCL1(%s,%s,%s,%s)"
        (ppa_pds_state source_state) (ppa_pds_state target_state) (pretty_var x)
          (pretty_record_value r)
    | Record_construction_lookup_2_of_2(
        source_state,target_state,x,r,patsp,patsn) ->
      Printf.sprintf "RCL2(%s,%s,%s,%s,%s,%s)"
        (ppa_pds_state source_state) (ppa_pds_state target_state) (pretty_var x)
          (pretty_record_value r) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Function_filter_validation(x) ->
      Printf.sprintf "FunFilVal(%s)" (pretty_var x)
  ;;

  type pds_untargeted_dynamic_pop_action =
    | Do_jump
      (** The action for performing basic jump operations. *)
    [@@deriving ord]
  ;; (* TODO *)
  
  let pp_pds_untargeted_dynamic_pop_action action =
    match action with
    | Do_jump -> "Do_jump"
  ;;

  let ppa_pds_untargeted_dynamic_pop_action action =
    match action with
    | Do_jump -> "Do_jump"
  ;;

  module Dph =
  struct
    type stack_element = pds_continuation;;
    type state = pds_state;;
    type targeted_dynamic_pop_action = pds_targeted_dynamic_pop_action;;
    type untargeted_dynamic_pop_action = pds_untargeted_dynamic_pop_action;;
    type stack_action =
      ( stack_element
      , targeted_dynamic_pop_action
      ) pds_stack_action
    ;;
    let compare_targeted_dynamic_pop_action =
      compare_pds_targeted_dynamic_pop_action;;
    let pp_targeted_dynamic_pop_action = pp_pds_targeted_dynamic_pop_action;;
    let ppa_targeted_dynamic_pop_action = ppa_pds_targeted_dynamic_pop_action;;
    let compare_untargeted_dynamic_pop_action =
      compare_pds_untargeted_dynamic_pop_action;;
    let pp_untargeted_dynamic_pop_action =
      pp_pds_untargeted_dynamic_pop_action;;
    let ppa_untargeted_dynamic_pop_action =
      ppa_pds_untargeted_dynamic_pop_action;;
    let perform_targeted_dynamic_pop element action =
      Logger_utils.lazy_bracket_log (lazy_logger `trace)
        (fun () ->
          Printf.sprintf "perform_targeted_dynamic_pop (%s) (%s)"
            (pp_pds_continuation element)
            (pp_pds_targeted_dynamic_pop_action action))
        (fun results ->
          String_utils.concat_sep_delim "[" "]" ", "
            (
              results
              |> Enum.clone
              |> Enum.map (String_utils.pretty_list @@
                  pp_pds_stack_action pp_pds_continuation
                    pp_pds_targeted_dynamic_pop_action)
            )
        )
      @@ fun () ->
      Nondeterminism_monad.enum @@
      let open Nondeterminism_monad in
      match action with
      | Variable_discovery x ->
        let%orzero (Lookup_var(x',patsp,patsn)) = element in
        [%guard equal_var x x'];
        [%guard Pattern_set.is_empty patsp];
        [%guard Pattern_set.is_empty patsn];
        (* If we've gotten this far, then we just need to pop the element in
           question; no other actions are required.  Strictly speaking, this
           could be accomplished with a static pop rather than a dynamic one.
           It's here for now because its presence homogenizes the rule
           implementations. *)
        return []
      | Variable_aliasing(x2,x1) ->
        let%orzero (Lookup_var(x',patsp,patsn)) = element in
        [%guard equal_var x' x2];
        (* We're looking for x2 and we've discovered here that it's aliased to
           x1. *)
        return [Push(Lookup_var(x1,patsp,patsn))]
      | Stateless_nonmatching_clause_skip_1_of_2 x'' ->
        let%orzero (Lookup_var(x,_,_)) = element in
        [%guard (not @@ equal_var x x'')];
        (* We're looking for a variable which does not match the one in this
           clause.  If we're stateless, that'll be fine. *)
        return [Pop_dynamic_targeted(
                  Stateless_nonmatching_clause_skip_2_of_2 element)]
      | Stateless_nonmatching_clause_skip_2_of_2 element' ->
        begin
          match element with
          | Deref(_,_) ->
            (* This means we're in a stateful mode.  Stateless non-matching
               clause skip is inappropriate here. *)
            zero ()
          | _ ->
            (* We're not in a stateful mode, so we can skip the clause.  We
               still have to put these elements back on the stack, though. *)
            return [Push(element);Push(element')]
        end
      | Function_closure_lookup(x'',xf) ->
        let%orzero (Lookup_var(x,_,_)) = element in
        [%guard (not @@ equal_var x x'')];
        (* We're looking for a non-local variable.  Push a lookup for the
           function. *)
        return [ Push(element)
               ; Push(Lookup_var(xf,Pattern_set.empty,Pattern_set.empty))
               ]
      | Conditional_closure_lookup(xc,pat,positive_side) ->
        let%orzero (Lookup_var(x,patsp,patsn)) = element in
        if not @@ equal_var x xc
        then return [Push(element)]
        else
          let (patsp',patsn') =
            if positive_side
            then (Pattern_set.add pat patsp,patsn)
            else (patsp,Pattern_set.add pat patsn)
          in
          return [Push(Lookup_var(x,patsp',patsn'))]
      | Record_projection_lookup(x,x',l) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [%guard (equal_var x0 x)];
        return [ Push(Project(l,patsp,patsn))
               ; Push(Lookup_var(x',Pattern_set.empty,Pattern_set.empty))
               ]
      | Record_construction_lookup_1_of_2(source_state,taret_state,x,r) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        logger `trace (Printf.sprintf ":::::::1   x=>%s   r=>%s   patsp=>%s   patsn=>%s   records-allowed=>%s" (pretty_var x) (pretty_record_value r)
          (pp_pattern_set patsp) (pp_pattern_set patsn)
          (string_of_bool @@ not @@ Pattern_set.mem (Record_pattern Ident_map.empty) patsn)
          );
        (* FIXME: the following isn't in the spec, but maybe it should be... just here to test things for now *)
        [% guard (not @@ Pattern_set.mem (Record_pattern Ident_map.empty) patsn) ];
        return @@ List.of_enum @@ Nondeterminism_monad.enum @@
        begin
          let open Nondeterminism_monad in
          let%bind patsn' = negative_pattern_set_selection r patsn in
          logger `trace (Printf.sprintf ":::::::2   patsn=>%s   picked=>%s"
            (pp_pattern_set patsn) (pp_pattern_set patsn'));
          return @@ Pop_dynamic_targeted(
                      Record_construction_lookup_2_of_2(
                        source_state,taret_state,x,r,patsp,patsn'))
        end
      | Record_construction_lookup_2_of_2(
          source_state,target_state,x,r,patsp0,patsn2) ->
        let Record_value m = r in
        let Pds_state(acl1,ctx1) = source_state in
        let Pds_state(acl0,ctx0) = target_state in
        begin
          match element with
          | Project(l,patsp1,patsn1) ->
            [% guard (Ident_map.mem l m) ];
            let x' = Ident_map.find l m in
            (* This case is record projection. *)
            return [ Push(Lookup_var( x'
                                    , (Pattern_set.union patsp1
                                        (pattern_set_projection patsp0 l))
                                    , (Pattern_set.union patsn1
                                        (pattern_set_projection patsn2 l))))
                   ; Push(Jump(acl0,ctx0))
                   ; Push(Lookup_var(x, patsp0, patsn2))
                   ]
          | _ ->
            (* This case is record validation. *)
            let record_labels = labels_in_record r in
            let pattern_set_labels = labels_in_pattern_set patsp0 in
            [%guard (Ident_set.subset pattern_set_labels record_labels) ];
            let make_k'' l =
              let x'' = Ident_map.find l m in
              List.enum [ Push(Lookup_var( x''
                                         , pattern_set_projection patsp0 l
                                         , pattern_set_projection patsn2 l))
                        ; Push(Jump(acl1,ctx1))
                        ]
            in
            let first_pushes =
              List.enum [ Push(element)
                        ; Push(Lookup_var( x
                                         , Pattern_set.empty
                                         , Pattern_set.empty))
                        ; Push(Jump(acl0,ctx0))
                        ]
            in
            let all_pushes =
              record_labels
              |> Ident_set.enum
              |> Enum.map make_k''
              |> Enum.concat
              |> Enum.append first_pushes
            in
            return @@ List.of_enum all_pushes
        end
      | Function_filter_validation(x) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        [% guard (Pattern_set.is_empty patsp) ];
        (* The following isn't strictly necessary, but it'd be redundant to do
           this for an empty negative pattern set. *)
        [% guard (not @@ Pattern_set.is_empty patsn) ];
        return [ Push(Lookup_var(x0,Pattern_set.empty,Pattern_set.empty)) ]
    ;;
    let perform_untargeted_dynamic_pop element action =
      Nondeterminism_monad.enum @@
      let open Nondeterminism_monad in
      match action with
      | Do_jump ->
        begin
          let%orzero (Jump(acl1,ctx)) = element in
          return ([], Pds_state(acl1,ctx))
        end
    ;;
  end;;
  
  module Ddpa_pds_reachability = Pds_reachability.Make(Ddpa_pds_reachability_basis)(Dph);;

  type ddpa_analysis_logging_data =
    { ddpa_logging_prefix : string
    ; ddpa_closure_steps : int
    }

  type ddpa_analysis =
    { ddpa_graph : ddpa_graph
    ; ddpa_graph_fully_closed : bool
    ; pds_reachability : Ddpa_pds_reachability.analysis
    ; ddpa_active_nodes : Annotated_clause_set.t
        (** The active nodes in the DDPA graph.  This set is maintained
            incrementally as edges are added. *)
    ; ddpa_active_non_immediate_nodes : Annotated_clause_set.t
        (** A subset of [ddpa_active_nodes] which only contains the non-immediate
            nodes.  This is useful during closure. *)
    ; ddpa_logging_data : ddpa_analysis_logging_data option
        (** Data associated with logging, if appropriate. *)
    }
  ;;

  let pp_ddpa analysis =
    Printf.sprintf
      "{\n  ddpa_graph = %s;\n  ddpa_graph_fully_closed = %s;\n  pds_reachability = %s;\n  ddpa_active_nodes = %s;\n  ddpa_active_non_immediate_nodes = %s;\n}"
      (pp_ddpa_graph analysis.ddpa_graph)
      (string_of_bool analysis.ddpa_graph_fully_closed)
      (Ddpa_pds_reachability.pp_analysis analysis.pds_reachability)
      (pp_annotated_clause_set analysis.ddpa_active_nodes)
      (pp_annotated_clause_set analysis.ddpa_active_non_immediate_nodes)
  ;;

  let empty_analysis logging_prefix_opt =
    (* The initial reachability analysis should include an edge function which
       always allows discarding the bottom-of-stack marker. *)
    let empty_reachability =
      Ddpa_pds_reachability.empty ~logging_prefix:logging_prefix_opt ()
    in
    let initial_reachability =
      empty_reachability
      |> Ddpa_pds_reachability.add_edge_function
        (fun state -> Enum.singleton ([Pop Bottom_of_stack], state))
    in
    { ddpa_graph = Ddpa_graph.empty
    ; ddpa_graph_fully_closed = true
    ; pds_reachability = initial_reachability  
    ; ddpa_active_nodes = Annotated_clause_set.singleton Start_clause
    ; ddpa_active_non_immediate_nodes = Annotated_clause_set.empty
    ; ddpa_logging_data = None
    }
  ;;

  let log_ddpa_graph level analysis name_fn =
    match analysis.ddpa_logging_data with
    | None -> ()
    | Some data ->
      let name = name_fn data in
      Ddpa_graph_logger.log level name analysis.ddpa_graph
  ;;

  let add_edges edges analysis =
    let already_present =
      Enum.clone edges
      |> Enum.for_all
        (fun edge -> Ddpa_graph.has_edge edge analysis.ddpa_graph)
    in
    if already_present then (analysis,false) else
      (* ***
        First, update the PDS reachability analysis with the new edge
        information.
      *)
      let add_edge_for_reachability edge reachability =
        (* ***
          First, create each edge and untargeted pop functions for this edge.
        *)
        let (Ddpa_edge(acl1,acl0)) = edge in
        let edge_function (Pds_state(acl0',ctx) as state) =
          Logger_utils.lazy_bracket_log (lazy_logger `trace)
          (fun () -> Printf.sprintf "DDPA %s edge function at state %s"
                        (pp_ddpa_edge edge) (pp_pds_state state))
          (fun edges ->
            let pretty_output (actions,target) =
              String_utils.pretty_tuple
                (String_utils.pretty_list Ddpa_pds_reachability.pp_stack_action)
                pp_pds_state
                (actions,target)
            in
            Printf.sprintf "Generates edges: %s"
                        (String_utils.pretty_list pretty_output @@
                          List.of_enum @@ Enum.clone edges)) @@
          fun () ->
          (* TODO: There should be a way to associate each edge function with
                   its corresponding acl0. *)
          if compare_annotated_clause acl0 acl0' <> 0 then Enum.empty () else
            let open Option.Monad in
            let zero () = None in
            let targeted_dynamic_pops = Enum.filter_map identity @@ List.enum
              [
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x, Abs_value_body _))) = acl1
                  in
                  (* x = v *)
                  return (Variable_discovery x,Pds_state(acl1,ctx))
                end
              ;
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x, Abs_var_body x'))) = acl1
                  in
                  (* x = x' *)
                  return (Variable_aliasing(x,x'),Pds_state(acl1,ctx))
                end
              ;
                begin
                  let%orzero (Enter_clause(x,x',c)) = acl1 in
                  (* x =(down)c x' *)
                  [%guard C.is_top c ctx];
                  let ctx' = C.pop ctx in
                  return (Variable_aliasing(x,x'),Pds_state(acl1,ctx'))
                end
              ;
                begin
                  let%orzero (Exit_clause(x,x',c)) = acl1 in
                  (* x =(up)c x' *)
                  let ctx' = C.push c ctx in
                  return (Variable_aliasing(x,x'),Pds_state(acl1,ctx'))
                end
              ;
                begin
                  let%orzero (Unannotated_clause(Abs_clause(x,_))) = acl1 in
                  (* x'' = b *)
                  return ( Stateless_nonmatching_clause_skip_1_of_2 x
                         , Pds_state(acl1,ctx)
                         )
                end
              ;
                begin
                  let%orzero (Enter_clause(x'',_,c)) = acl1 in
                  let%orzero (Abs_clause(_,Abs_appl_body(xf,_))) = c in
                  (* x'' =(down)c x' for functions *)
                  [%guard C.is_top c ctx];
                  let ctx' = C.pop ctx in
                  return ( Function_closure_lookup(x'',xf)
                         , Pds_state(acl1,ctx')
                         )
                end
              ;
                begin
                  (* This block represents *all* conditional closure
                     handling. *)
                  let%orzero (Enter_clause(x'',_,c)) = acl1 in
                  let%orzero
                    (Abs_clause(_,Abs_conditional_body(x1,p,f1,_))) = c
                  in
                  let Abs_function_value(f1x,_) = f1 in
                  (* x'' =(down)c x' for conditionals *)
                  [%guard C.is_top c ctx];
                  [%guard (not @@ equal_var x'' x1)];
                  let closure_for_positive_path = equal_var f1x x'' in
                  return ( Conditional_closure_lookup
                            (x1,p,closure_for_positive_path)
                         , Pds_state(acl1,C.pop ctx)
                         )
                end
              ;
                begin
                  let%orzero
                    (Unannotated_clause(
                      Abs_clause(x,Abs_projection_body(x',l)))) = acl1
                  in
                  (* x = x'.l *)
                  return (Record_projection_lookup(x,x',l),Pds_state(acl1,ctx))
                end
              ;
                begin
                  let%orzero
                    (Unannotated_clause(
                      Abs_clause(x,Abs_value_body(Abs_value_record(r))))) = acl1
                  in
                  (* x = r *)
                  let source_state = Pds_state(acl1,ctx) in
                  let target_state = Pds_state(acl0,ctx) in
                  return ( Record_construction_lookup_1_of_2(
                             source_state,target_state,x,r)
                         , target_state
                         )
                end
              ;
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                        x,Abs_value_body(Abs_value_function(_))))) = acl1
                  in
                  (* x = f *)
                  return (Function_filter_validation(x), Pds_state(acl0,ctx))
                end
              ]
            in
            targeted_dynamic_pops
            |> Enum.map
                (fun (action,state) -> ([Pop_dynamic_targeted(action)], state))
        in
        let untargeted_dynamic_pop_action_function (Pds_state(acl0',_)) =
          (* TODO: There should be a way to associate each action function with
                   its corresponding acl0. *)
          if compare_annotated_clause acl0 acl0' <> 0 then Enum.empty () else
            let open Option.Monad in
            (* let zero () = None in *)
            let untargeted_dynamic_pops = Enum.filter_map identity @@ List.enum
              [
                begin
                  return @@ Do_jump
                end
              ]
            in
            untargeted_dynamic_pops
        in
        reachability
        |> Ddpa_pds_reachability.add_edge_function edge_function
        |> Ddpa_pds_reachability.add_untargeted_dynamic_pop_action_function
            untargeted_dynamic_pop_action_function
      in
      let pds_reachability' =
        Enum.clone edges
        |> Enum.fold (flip add_edge_for_reachability) analysis.pds_reachability
      in
      (* ***
        Next, add the edge to the DDPA graph.
      *)
      let ddpa_graph' =
        Enum.clone edges
        |> Enum.fold (flip Ddpa_graph.add_edge) analysis.ddpa_graph 
      in
      (* ***
        Now, perform closure over the active node set.  This function uses a
        list of enumerations of nodes to explore.  This reduces the cost of
        managing the work queue.
      *)
      let rec find_new_active_nodes from_acls_enums results_so_far =
        match from_acls_enums with
        | [] -> results_so_far
        | from_acls_enum::from_acls_enums' ->
          if Enum.is_empty from_acls_enum
          then find_new_active_nodes from_acls_enums' results_so_far
          else
            let from_acl = Enum.get_exn from_acls_enum in
            if Annotated_clause_set.mem from_acl analysis.ddpa_active_nodes ||
               Annotated_clause_set.mem from_acl results_so_far
            then find_new_active_nodes from_acls_enums results_so_far
            else
              let results_so_far' =
                Annotated_clause_set.add from_acl results_so_far
              in
              let from_here = ddpa_graph' |> Ddpa_graph.succs from_acl in
              find_new_active_nodes (from_here::from_acls_enums) results_so_far'
      in
      let (ddpa_active_nodes',ddpa_active_non_immediate_nodes') =
        let new_active_root_nodes =
          Enum.clone edges
          |> Enum.filter_map
            (fun (Ddpa_edge(acl_left,acl_right)) ->
              if Annotated_clause_set.mem acl_left analysis.ddpa_active_nodes
              then Some acl_right
              else None)
          |> Enum.filter
            (fun acl ->
              not @@ Annotated_clause_set.mem acl analysis.ddpa_active_nodes)
        in
        let new_active_nodes =
          find_new_active_nodes [new_active_root_nodes]
            Annotated_clause_set.empty
        in
        ( Annotated_clause_set.union analysis.ddpa_active_nodes
            new_active_nodes
        , Annotated_clause_set.union analysis.ddpa_active_non_immediate_nodes
            ( new_active_nodes |> Annotated_clause_set.filter
                (not % is_annotated_clause_immediate) )
        )
      in
      (
        { ddpa_graph = ddpa_graph'
        ; ddpa_graph_fully_closed = false
        ; pds_reachability =  pds_reachability'
        ; ddpa_active_nodes = ddpa_active_nodes'
        ; ddpa_active_non_immediate_nodes = ddpa_active_non_immediate_nodes'
        ; ddpa_logging_data = analysis.ddpa_logging_data
        }
      , true
      )
  ;;

  let create_initial_analysis ?logging_prefix:(logging_prefix=None) e =
    let Abs_expr(cls) = lift_expr e in
    (* Put the annotated clauses together. *)
    let acls =
      List.enum cls
      |> Enum.map (fun x -> Unannotated_clause x)
      |> Enum.append (Enum.singleton Start_clause)
      |> flip Enum.append (Enum.singleton End_clause)
    in
    (* For each pair, produce a DDPA edge. *)
    let rec mk_edges acls' =
      match Enum.get acls' with
      | None -> []
      | Some acl1 ->
        match Enum.peek acls' with
        | None -> []
        | Some acl2 ->
          Ddpa_edge(acl1,acl2) :: mk_edges acls'
    in
    let edges = List.enum @@ mk_edges acls in
    let empty_analysis' =
      match logging_prefix with
      | None -> empty_analysis None
      | Some prefix ->
        { (empty_analysis @@ Some prefix) with
          ddpa_logging_data = Some
            { ddpa_closure_steps = 0
            ; ddpa_logging_prefix = prefix
            }
        }
    in
    let analysis = fst @@ add_edges edges empty_analysis' in
    logger `trace "Created initial analysis";
    log_ddpa_graph Ddpa_graph_logger.Ddpa_log_all analysis
      (fun data ->
        Ddpa_graph_logger.Ddpa_graph_name_initial data.ddpa_logging_prefix);
    analysis
  ;;

  let restricted_values_of_variable acl x patsp patsn analysis =
    Logger_utils.lazy_bracket_log (lazy_logger `trace)
      (fun () ->
        Printf.sprintf "Determining values of variable %s at position %s%s"
          (pretty_var x) (pp_annotated_clause acl) @@
          if Pattern_set.is_empty patsp && Pattern_set.is_empty patsn
          then ""
          else
            Printf.sprintf " with pattern sets %s and %s"
              (pp_pattern_set patsp) (pp_pattern_set patsn)
          )
      (fun (values, _) ->
        String_utils.concat_sep_delim "{" "}" ", " @@
          Enum.map pp_abstract_value @@ Enum.clone values)
    @@ fun () ->
    let start_state = Pds_state(acl,C.empty) in
    let start_actions =
      [Push Bottom_of_stack; Push (Lookup_var(x,patsp,patsn))]
    in
    let reachability = analysis.pds_reachability in
    let reachability' =
      reachability
      |> Ddpa_pds_reachability.add_start_state start_state start_actions
    in
    let analysis' = { analysis with pds_reachability = reachability' } in
    let values =
      reachability'
      |> Ddpa_pds_reachability.get_reachable_states start_state start_actions
      |> Enum.filter_map
        (fun (Pds_state(acl,_)) ->
          match acl with
          | Unannotated_clause(Abs_clause(_,Abs_value_body(v))) -> Some v
          | _ -> None)
    in
    (values, analysis')
  ;;

  let values_of_variable acl x analysis =
    let (values, analysis') =
      restricted_values_of_variable acl x
        Pattern_set.empty Pattern_set.empty analysis
    in
    (Abs_value_set.of_enum values, analysis')
  ;;

  let rv body =
    match body with
    | [] -> raise @@ Utils.Invariant_failure "empty function body provided to rv"
    | _ -> let Abs_clause(x,_) = List.last body in x
  ;;

  let wire site_cl func x1 x2 graph =
    let site_acl = Unannotated_clause(site_cl) in
    let Abs_function_value(x0, Abs_expr(body)) = func in
    let wire_in_acl = Enter_clause(x0,x1,site_cl) in
    let wire_out_acl = Exit_clause(x2,rv body,site_cl) in
    let pred_edges =
      Ddpa_graph.preds site_acl graph
      |> Enum.map (fun acl' -> Ddpa_edge(acl',wire_in_acl))
    in
    let succ_edges =
      Ddpa_graph.succs site_acl graph
      |> Enum.map (fun acl' -> Ddpa_edge(wire_out_acl,acl'))
    in
    let inner_edges =
      List.enum body
      |> Enum.map (fun cl -> Unannotated_clause(cl))
      |> Enum.append (Enum.singleton wire_in_acl)
      |> flip Enum.append (Enum.singleton wire_out_acl)
      |> Utils.pairwise_enum_fold
          (fun acl1 acl2 -> Ddpa_edge(acl1,acl2))
    in
    Enum.append pred_edges @@ Enum.append inner_edges succ_edges
  ;;

  let perform_closure_steps analysis =
    begin
      match analysis.ddpa_logging_data with
      | None -> logger `trace "Performing closure step"
      | Some data -> logger `trace
          (Printf.sprintf "Performing closure step %d"
            (data.ddpa_closure_steps+1));
    end;
    (* We need to do work on each of the active, non-immediate nodes.  This
       process includes variable lookups, which may result in additional work
       being done; as a result, each closure step might change the underlying
       graph.  We'll keep the analysis in a ref so that, whenever work is done
       which produces a new analysis, we can just update the ref. *)
    let analysis_ref = ref analysis in
    let new_edges_enum = Nondeterminism_monad.enum
      (
        let open Nondeterminism_monad in
        let%bind acl =
          pick_enum @@
            Annotated_clause_set.enum analysis.ddpa_active_non_immediate_nodes
        in
        let has_values x patsp patsn =
          let (values,analysis') =
            restricted_values_of_variable acl x patsp patsn !analysis_ref
          in
          analysis_ref := analysis';
          not @@ Enum.is_empty values
        in
        match acl with
        | Unannotated_clause(Abs_clause(x1,Abs_appl_body(x2,x3)) as cl) ->
          lazy_logger `trace
            (fun () ->
              Printf.sprintf "Considering application closure for clause %s"
                (pp_abstract_clause cl));
          (* Make sure that a value shows up to the argument. *)
          [%guard has_values x3 Pattern_set.empty Pattern_set.empty];
          (* Get each of the function values. *)
          let (x2_values,analysis_2) =
            restricted_values_of_variable
              acl x2 Pattern_set.empty Pattern_set.empty !analysis_ref
          in
          analysis_ref := analysis_2;
          let%bind x2_value = pick_enum x2_values in
          let%orzero Abs_value_function(fn) = x2_value in
          (* Wire each one in. *)
          return @@ wire cl fn x3 x1 analysis_2.ddpa_graph
        | Unannotated_clause(
            Abs_clause(x1,Abs_conditional_body(x2,p,f1,f2)) as cl) ->
          lazy_logger `trace
            (fun () ->
              Printf.sprintf "Considering conditional closure for clause %s"
                (pp_abstract_clause cl));
          (* We have two functions we may wish to wire: f1 (if x2 has values
             which match the pattern) and f2 (if x2 has values which antimatch
             the pattern). *)
          [ (Pattern_set.singleton p, Pattern_set.empty, f1)
          ; (Pattern_set.empty, Pattern_set.singleton p, f2)
          ]
            |> List.enum
            |> Enum.filter_map
              (fun (patsp,patsn,f) ->
                if has_values x2 patsp patsn then Some f else None)
            |> Enum.map (fun f -> wire cl f x2 x1 (!analysis_ref).ddpa_graph)
            |> Nondeterminism_monad.pick_enum
        | _ ->
          raise @@ Utils.Invariant_failure
            "Unhandled clause in perform_closure_steps"
      )
        |> Enum.concat
    in
    (* Due to the stateful effects of computing the new edges, we're going to
       want to pull on the entire enumeration before we start looking at the
       analysis. *)
    let new_edges_list = List.of_enum new_edges_enum in
    (* Now we want to add all of the new edges.  If there are any new ones, we
       need to know about it. *)
    let (analysis',any_new) =
      add_edges (List.enum new_edges_list) !analysis_ref
    in
    let ddpa_logging_data' =
      match analysis'.ddpa_logging_data with
      | None -> None
      | Some data ->
        Some { data with ddpa_closure_steps = data.ddpa_closure_steps+1 }
    in
    let result = 
      { analysis' with
        ddpa_graph_fully_closed = not any_new;
        ddpa_logging_data = ddpa_logging_data'
      }
    in
    begin
      match result.ddpa_logging_data with
      | None -> logger `trace "Completed closure step"
      | Some data -> logger `trace
          (Printf.sprintf "Completed closure step %d"
            (data.ddpa_closure_steps));
    end;
    log_ddpa_graph Ddpa_graph_logger.Ddpa_log_all analysis
      (fun data -> Ddpa_graph_logger.Ddpa_graph_name_intermediate(
          data.ddpa_logging_prefix, data.ddpa_closure_steps));
    result
  ;;
  
  let is_fully_closed analysis = analysis.ddpa_graph_fully_closed;;
  
  let rec perform_full_closure analysis =
    if is_fully_closed analysis
    then
      begin
        logger `trace "Closure complete.";
        log_ddpa_graph Ddpa_graph_logger.Ddpa_log_result analysis
          (fun data ->
            Ddpa_graph_logger.Ddpa_graph_name_closed(data.ddpa_logging_prefix));
        analysis
      end
    else
      begin
        perform_full_closure @@ perform_closure_steps analysis
      end
  ;;

  let set_pdr_logger_level level =
    Ddpa_pds_reachability.set_logging_level level
  ;;

  let get_pdr_logger_level () =
    Ddpa_pds_reachability.get_logging_level ()
  ;;
end;;
