This concolic solver hits every possible path, not just every possible branch.

TODO: 
* assert and assume constraints. If they failed, then move all formulas to "child.constraint" and set as unsolved
* reach max step
* faster target compare
  * potentially by letting lookup key keep more complete stack
* record formulas! I think this is why we miss the target. Otherwise missing the target should be impossible, I think
* Store formulas separately that are not dependent on inputs
* " go back 2, then 4, then 16 ... targets to roll off more in case we're stuck in a loop"
  * ie exponential rollback

### 7 Feb 2024

Summary of last meeting:
* We talked about using the "implies" inside the solver versus selectively adding all necessary formulas ourselves
  * This goes hand-in-hand with solving for some specific instance of a branch instead of solving for all at once
  * The former is more traditional. The latter is my spin

My progress:
* I created a "strict" concolic evaluator over the weekend that is just missing a few features
  * Let's talk about the differences, please!

Notes:
* https://www.burn.im/crest/ 
  * ^ Publications incluencing CREST, which is improved CUTE: concolic unit testing for C
* https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4639362
  * Heuristics for path exploration (e.g. static analysis to find branches that lead to more program discovery)
* https://www.researchgate.net/publication/49456034_Oasis_Concolic_Execution_Driven_by_Test_Suites_and_Code_Modifications
  * See 3.4: Search Strategy
  * Has excellent results with no path exploration heuristics like above
    * Though they say the heuristics would probably improve their product if they had tried them

### 13 Feb 2023

Summary of last meeting:
* We decided to look at how others do concolic evaluation
* We talked briefly about bitvectors to be used in the solver to describe types

Progess:
* The videos didn't lend much. They didn't offer solutions and only explained the problems
* The evaluator now seems to only be wrong in the record matching cases
* I'm still not sure the best way to get around max step
  * Discarding formulas leads us to continually hit the issue again and again due to lack of info
    * Keep only n targets every time
  * Tips for how to choose which targets or formulas will dodge the issue?
* I'm not sure how we handle exponential rollback

My proposed next steps:
* I should dedicate my time to the fixing how the solver handles records
  * Shiwei doesn't seem to consider this high priority for himself
* We talk about heuristics for how to roll back
  * How do we decide targets to discard? Do we risk missing important branches? Try to recognize a recursive function and ignore branches inside it?
* I also need to selectively add inputs that necessarily affect the target condition
  * I already limit to only formulas on the path (and with no "implies"), but I don't remove irrelevant formulas
  * I can do this by tracking which clauses each clause necessarily depends on.
    * We want to know what the condition depends on
    * Then follow those dependencies until we reach atoms: clauses that depend on nothing.
      * Each clause also has its own expression, and it must be added to the solver whenever a later clause depends on it
    * Do the same for any clause in the constraints for the branch
    * Join with any expressions in the constraints (e.g. that the assume must be true. This is an expression, not a dependency)