\section{Intro}

In this section, we will first provide the model theory definition of types in 
our language. However, since in real programs, we cannot effectively perform 
certain mathematical enumerations (such as enumeration of functions), we will 
need an operational-semantics-based definition of how typechecking works in actual 
programs. As such, we will provide a proof theory definition of types, and prove
equivalence of the two systems.

\section{Core Language}

First, we'll define a small core language with basic integers, booleans, binary 
operations, conditionals, and functions.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \ev
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \expr\ \expr
                \gline
                \gor \expr\ \binop\ \expr
                \gor \ife{\expr}{\expr}{\expr}
                \gor \letin{\ev}{\expr}{\expr}
                \gline 
                \gor \matches{\expr}{p}
                \gor \pick_i 
                \gor \pick_b
                \gor \eerror
            }
            \grule[variables]{\ev}{
                        \textit{(identifiers)}
            }
            \grule[patterns]{p}{
              \tint
              \gor \tbool
              \gor \gtfun
            }
            \grule[values]{\eval}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \gtfun\ \ev \gtarrow \expr
            }
            \grule[types]{\syntype}{
              \tint
              \gor \tbool
              \gor \tfun
          }
        \end{grammar}
    \caption{Core language grammar}
    \label{fig_Grammar}
\end{figure}

\subsection{Modeling Types Mathematically}

The typing rules of the system is defined as following:

\begin{definition}[Typing rules]
  \label{def_typingM}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\tint}$ iff $\expr \nsmallsteps[] \eerror$ and $\forall \eval. \expr \smallsteps[] \eval$, $\eval \in \mathbb{Z}$.
      \item $\ \models \hastype{\expr}{\tbool}$ iff $\expr \nsmallsteps[] \eerror$ and $\forall \eval.\expr \smallsteps[] \eval$, $\eval \in \mathbb{B}$.
      \item $\ \models \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$ iff $\expr \nsmallsteps[] \eerror$ and $\forall \eval_f.$ if $\expr \smallsteps[] \eval_f$, \\ then $\forall{\eval}.$ if $\models \hastype{\eval}{\syntype_1}$, then $\models \hastype{\eval_f\ \eval}{\syntype_2}$.
   \end{enumerate}
\end{definition}

Note that the rules do not actually check the types of the subexpressions. In 
fact, we can have an expression such as \texttt{Y}\ 
\texttt{(fun this -> fun n -> if n = 0 then 0 else this (n-1))} and 
assign the type \texttt{int -> int} to it, in spite of the fact that
we cannot assign types to any of its subexpressions.

\subsection{Modeling Types Practically}

In this section, we will provide the proof theory definition of typechecking.

\begin{definition}[Type Generator]
  \label{def_genCore}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkgen{\tint} = \pick_i$
    \item $\mkgen{\tbool} = \pick_b$
    \item $\mkgen{\mkfun{\syntype_1}{\syntype_2}} = \mkfunv{\ev}{\letin{\_}{\mkche{\syntype_1}{\ev}}{\mkgen{\syntype_2}}}$
  \end{enumerate}
\end{definition}

\begin{definition}[Type Checker]
  \label{def_checkCore}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\mkche{\tint}{\expr} = \ife{\matches{\expr}{\tint}}{\expr}{\eerror}$
      \item $\mkche{\tbool}{\expr} = \ife{\matches{\expr}{\tbool}}{\expr}{\eerror}$
      \item $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\expr} = \\
       \texttt{let arg = }\mkgen{\syntype_1} \texttt{ in }\letin{\_}{\mkche{\syntype_2}{\texttt{(e arg)}}}{\texttt{e}}$
   \end{enumerate}
\end{definition}

\begin{definition}[Updated typing rule]
  \ \par
  $\models_p \hastype{\expr}{\syntype}$ iff $\mkche{\syntype}{\expr} \nsmallsteps[] \eerror$.
\end{definition}

\subsection{Completeness and Soundness}

In this section, we will show that the two definitions are equivalent.

\begin{theorem}
  $\forall \expr.$ $\not\models_p \hastype{\expr}{\syntype}$ iff $\not\models \hastype{\expr}{\syntype}$.
\end{theorem}

\begin{proof}[if direction]
  $\forall \expr.$ if $\not\models_p \hastype{\expr}{\syntype}$, then $\not\models \hastype{\expr}{\syntype}$.

  This is equivalent to showing: if $\mkche{\syntype}{\expr} \smallsteps[] \eerror$, then $\not\models \hastype{\expr}{\syntype}$.

  To prove this statement, we'll need the following lemma:

  \begin{lemma}
    $\models \hastype{\mkgen{\syntype}}{\syntype}$.
  \end{lemma}

  We will prove the conjunction of the completeness statement and the lemma by induction on the structure of $\syntype$.

  \textbf{Base case}: $\syntype = \tint$

  First, we will show that $\models \hastype{\mkgen{\tint}}{\tint}$.
  
  Since $\mkgen{\tint} = pick_i$, by definition of $\pick_i$, we know that $\forall \eval.$ if $\pick_i \smallsteps[] \eval$, then $\eval \in \mathbb{Z}$. Thus, we have shown that $\models \hastype{\mkgen{\tint}}{\tint}$.

  Next, we'll prove that for an arbitrary $\expr$, if $ \hastype{\expr}{\tint}$, then $\not\models \hastype{\expr}{\tint}$.

  By definition of $\vdash \hastype{\expr}{\tint}$, we know that $\not\models_p \hastype{\expr}{\tint}$ suggests $\mkche{\tint}{\expr} \smallsteps[] \eerror$. Examining the definition of $\mkche{\tint}{\expr}$, we can see that there are two potential sources for $\eerror$:
  \begin{enumerate}
    \item $\expr \smallsteps[] \eerror$. In this case, $\not\models \hastype{\expr}{\tint}$ is trivial. 
    \item $\expr \smallsteps[] \eval$. In this case, we know that $\matches{\eval}{\tint} \smallsteps[] \texttt{false}$, which means $\eval \notin \mathbb{Z}$. Thus $\not\models \hastype{\expr}{\tint}$. 
  \end{enumerate}

  Proof for the case where $\syntype = \tbool$ is very similar, so we'll omit it here for brevity.

  \textbf{Inductive step:} $\syntype = \mkfun{\syntype_1}{\syntype_2}$

  First, we will show that $\models \hastype{\mkgen{\mkfun{\syntype_1}{\syntype_2}}}{\mkfun{\syntype_1}{\syntype_2}}$.

  To prove this, we need to show that $\forall\eval.$ if $\hastype{\eval}{\syntype_1}$, then $\models \hastype{(\mkgen{\mkfun{\syntype_1}{\syntype_2}} \ \eval)}{\syntype_2}$.
  
  By definition, $(\mkgen{\mkfun{\syntype_1}{\syntype_2}}) \ \eval = \letin{\_}{\mkche{\syntype_1}{\eval}}{\mkgen{\syntype_2}}$.

  By inductive hypothesis, $\forall\eval.$ if $\models \hastype{\eval}{\syntype_1}$, then $\vdash \hastype{\eval}{\syntype_1}$, which means $\mkche{\syntype_1}{\eval}\nsmallsteps[] \eerror$. In the case that $\mkche{\syntype_1}{\eval}$ diverges, $(\mkgen{\mkfun{\syntype_1}{\syntype_2}}) \ \eval$ will diverge, too, making the statement $\models \hastype{(\mkgen{\mkfun{\syntype_1}{\syntype_2}} \ \eval)}{\syntype_2}$ trivially true. If $\mkche{\syntype_1}{\eval}$ doesn't diverge, we only have to consider $\mkgen{\syntype_2}$. By inductive hypothesis, we know that $\models \hastype{\mkgen{\syntype_2}}{\syntype_2}$. Therefore, we have shown that $\forall\eval.$ if $\hastype{\eval}{\syntype_1}$, then $\models \hastype{(\mkgen{\mkfun{\syntype_1}{\syntype_2}} \ \eval)}{\syntype_2}$, which means $\models \hastype{\mkgen{\mkfun{\syntype_1}{\syntype_2}}}{\mkfun{\syntype_1}{\syntype_2}}$.

  Next, we'll prove that for an arbitrary $\expr$, if $\not\models_p \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$, then $\not\models \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$.

  By definition, $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\expr} = \texttt{let arg = }\mkgen{\syntype_1} \texttt{ in }\mkche{\syntype_2}{\texttt{(e arg)}}$. Since $\mkgen{\syntype_1}$ is guaranteed to evaluate to a value, we know that $\eerror$ must come from $\mkche{\syntype_2}{\texttt{(e arg)}}$. This suggests that $\not\models_p \hastype{(\expr\ \texttt{arg})}{\syntype_2}$. By induction hypothesis, we know that $\not\models \hastype{(\texttt{\expr\ \texttt{arg}})}{\syntype_2}$, and that $\models \hastype{\mkgen{\syntype_1}}{\syntype_1}$. Thus we have found a witness $\models \hastype{\texttt{arg}}{\syntype_1}$ such that $\not\models \hastype{(\expr \ \texttt{arg})}{\syntype_2}$, proving that $\not\models \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$.

\end{proof}

\begin{proof}[Soundness]
  $\forall. \expr$ if $\not\models \hastype{\expr}{\syntype}$, then $\not\models_p \hastype{\expr}{\syntype}$.

  This is equivalent to showing: if $\not\models \hastype{\expr}{\syntype}$, then $\exists \eval. \expr \smallsteps[] \eval$ and $\mkche{\syntype}{\eval} \smallsteps[] \eerror$.

  Consider the case $\exists v_f. e \smallsteps[] v_f$ and $\exists \eval. \models \hastype{\eval}{\syntype_1}$

  \begin{definition}
    $\expr_1 \subseteq_{\syntype} \expr_2$ is defined as the following by case analysis:

    $\expr_1 \subseteq_{\tint} \expr_2$ iff $\forall \eval_1.$ if $\expr_1 \smallsteps[] \eval_1$, then $\expr_2 \smallsteps[] \eval_1$, $\eval_1 \in \mathbb{Z}$.

    $\expr_1 \subseteq_{\tbool} \expr_2$ iff $\forall \eval_1.$ if $\expr_1 \smallsteps[] \eval_1$, then $\expr_2 \smallsteps[] \eval_1$, $\eval_1 \in \mathbb{B}$.

    $\expr_1 \subseteq_{\mkfun{\syntype_1}{\syntype_2}} \expr_2$ iff $\forall \eval_1.$ if $\expr_1 \smallsteps[] \eval_1$, then $\exists \eval_2. \expr_2 \smallsteps[] \eval_2$, $\models \hastype{\eval_1, \eval_2}{\mkfun{\syntype_1}{\syntype_2}}$, and $\forall \eval, \eval_{r1}.$ if $\models \hastype{\eval}{\syntype_1}$ and $(\eval_1 \ \eval) \smallsteps[] \eval_{r1}$, then $\exists \eval_{r2}. (\eval_2 \ \eval) \smallsteps[] \eval_{r2}$ and $\eval_{r1} \subseteq_{\syntype_2} \eval_{r2}$.

  \end{definition}

  To prove this statement, we'll need the following lemma:

  \begin{lemma}
    If $\models \hastype{\eval}{\syntype}$, then $\eval \subseteq_{\syntype} \mkgen{\syntype}$.
  \end{lemma}

  \begin{definition}
    % Defining a tau context C
    For all context C, $\models \hastype{C[\bullet_{\syntype}]}{-}$ iff $\forall \eval.$ if $\models \hastype{\eval}{\syntype}$ then $C[\eval] \smallsteps[] \eval'$.
  \end{definition}

  \begin{lemma}
    $\forall. \eval$ if $\models \hastype{\eval}{\syntype}$, then $\forall. C$ if $\models \hastype{C[\bullet_{\syntype}]}{-}$ and $C[\eval] \smallsteps[] \eval_1$, then $C[\mkgen{\syntype}] \smallsteps[] \eval_2$ and $\eval_1 \subseteq_{\syntype} \eval_2$.
  \end{lemma}

\end{proof}

\section{Language extensions}

Next, we will define a couple of languages extensions and their corresponding typing rules.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
              \cdots
              \gor \vpoly
            }
            \grule[values]{\eval}{
              \cdots
              \gor \vpoly
            }
            \grule[types]{\syntype}{
              \cdots
              \gor \tpoly
              \gor \mkunion{\syntype}{\syntype}
              \gor \mkintersect{\syntype}{\syntype}
              \gor \mktset{\syntype}{\expr}
              \gor \mkdfun{\ev}{\syntype}{\syntype}
              \gor \mkmiu{\alpha}{\syntype}
          }
        \end{grammar}
    \caption{Extended language grammar}
    \label{ext_Grammar}
\end{figure}

\begin{definition}[More typing rules]
  \label{def_typingRulesExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\tpoly}$ iff $\expr \smallsteps[] \vpoly$, where $\textsc{typeof}(\vpoly) = \tpoly$.
      \item $\ \models \hastype{\expr}{\mkunion{\syntype_1}{\syntype_2}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall \eval.$ if $\expr \smallsteps[] \eval$, then $\ \models \hastype{\eval}{\syntype_1}$ or $\ \models \hastype{\eval}{\syntype_2}$.
      \item $\ \models \hastype{\expr}{\mkintersect{\syntype_1}{\syntype_2}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall \eval.$ if $\expr \smallsteps[] \eval$, then $\ \models \hastype{\eval}{\syntype_1}$ and $\ \models \hastype{\eval}{\syntype_2}$.
      \item $\ \models \hastype{\expr}{\mktset{\syntype}{p}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall \eval.$ if $\expr \smallsteps[] \eval$, \\ then $\ \models \hastype{\eval}{\syntype}$ and $p \ \eval \smallsteps[] \gttrue$.
      \item $\ \models \hastype{\expr}{\mkdfun{\ev}{\syntype_1}{\syntype_2}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall{\eval_f}$, if $\expr \smallsteps[] \eval_f$, \\ then $\forall \eval$, if $\models \hastype{\eval}{\syntype_1}$, then $\models \hastype{\eval_f\ \eval}{\substitute{\syntype_2}{\eval}{\ev}}$.
      \item $\ \models \hastype{\expr}{\mkmiu{\alpha}{\syntype}}$ iff ?.
  \end{enumerate}
\end{definition}

We will now extend the language with records.


\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
              \cdots
              \gor \{\overline{\elbl = \expr}\}^{\{\overline{\elbl}\}}
              \gor \expr.\elbl
            }
            \grule[values]{\eval}{
              \cdots
              \gor \{\overline{\elbl = \eval}\}^{\{\overline{\elbl}\}}
            }
            \grule[types]{\syntype}{
              \cdots
              \gor \{\overline{\hastype{\elbl}{\syntype}}\} 
          }
        \end{grammar}
    \caption{Extended language grammar (with records)}
    \label{rec_Grammar}
\end{figure}

\begin{definition}[Record typing rules]
  \label{def_typingRec}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\{\hastype{\elbl_1}{\syntype_1},\ \cdots, \hastype{\elbl_m}{\syntype_m}\}}$ iff $\expr \bigstep \{\elbl_1 = \eval_1,\ \cdots, \elbl_m = \eval_m,\ \cdots, \elbl_n = \eval_n\}^{\{\elbl_1, \cdots, \elbl_p\}}$ where $\ \models \hastype{\eval_i}{\syntype_i}$ for $i \in \{1,\ \cdots, m\}$, $n \geq p \geq m$.
  \end{enumerate}
\end{definition}

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \ev
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \expr\ \expr
                \gor \expr \ \binop \ \expr
                \gor \vpoly
                \gor \{\overline{\elbl = \expr}\}^{\{\overline{\elbl}\}}
                \gor \expr.\elbl
                \gline
                \gor \ife{\expr}{\expr}{\expr}
                \gor \pick_i
                \gor \pick_b
                \gor \matches{\expr}{p}
                \gor \mzero
                \gor \eerror
                \gline
                \gor \letin{\ev}{\expr}{\expr}
                \gor \letfun
                \gline
                \gor \letfunt
                \gor \letint{\ev}{\syntype}{\expr}{\expr}
            }
            \grule[variables]{\ev}{
                \textit{(identifiers)}
            }
            \grule[patterns]{p}{
                \tint
                \gor \tbool
                \gor \gtfun
                \gor \gtany
                \gor \vpoly
                \gor \{\overline{\elbl}\}
            }
            \grule[values]{\eval}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \ev
                \gor \vpoly
                \gor \{\overline{\elbl = \eval}\}^{\{\overline{\elbl}\}}
            }
            \grule[types]{\syntype}{
                \tint
                \gor \tbool
                \gor \tfun
                \gor \tpoly
                \gor \mkunion{\syntype}{\syntype}
                \gor \mkintersect{\syntype}{\syntype}
                \gor \mktset{\syntype}{\expr}
                \gor \mkdfun{\ev}{\syntype}{\syntype}
                \gor \mkmiu{\alpha}{\syntype}
                \gor \{\overline{\hastype{\elbl}{\syntype}}\}
          }
        \end{grammar}
    \caption{Complete language grammar}
    \label{fig_completeGrammar}
\end{figure}

\section{Type as values}

In this section, we will demonstrate how to represent each type using a tuple of functions $\genf$ and $\chef$.

\begin{definition}[Semantic interpretation of types]
  \label{def_typeAsVal}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  We define the semantic interpretation of types as $\llbracket \syntype \rrbracket = \{\texttt{gen = \mkgen{\syntype}, check = }\mkfunv{\expr}{\mkche{\syntype}{\expr}}\}$.
\end{definition}

% \begin{definition}[Defining Generator in the core language]
%   \label{def_genCore}
%   % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
%   \ \par 
%   \begin{enumerate}
%     \item $\mkgen{\tint} : \pick_i$.
%     \item $\mkgen{\tbool} : \pick_b$.
%     \item $\mkgen{\mkfun{\syntype_1}{\syntype_2}} : \mkfunv{\ev}{\mkgen{\syntype_2}}$.
%   \end{enumerate}
% \end{definition}

% \begin{definition}[Defining Checker in the core language]
%   \label{def_CheCore}
%   % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
%   \ \par 
%   \begin{enumerate}
%     \item $\mkche{\tint}{\expr} : \matches{\expr}{\tint}$.
%     \item $\mkche{\tbool}{\expr} : \matches{\expr}{\tbool}$.
%     \item $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\expr} : \texttt{let arg = }\mkgen{\syntype_1} \texttt{ in }\mkche{\syntype_2}{\texttt{(e arg)}}$.
%   \end{enumerate}
% \end{definition}

% \begin{definition}[Defining Generator in the extended language]
%   \label{def_genExt}
%   % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
%   \ \par 
%   \begin{enumerate}
%     \item $\mkgen{\tpoly_i} : \vpoly_i$.
%     \item $\mkgen{\mkunion{\syntype_1}{\syntype_2}} : \pick_b$. $\ife{b}{\mkgen{\syntype_1}}{\mkgen{\syntype_2}}$.
%     \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where $\syntype_1, \syntype_2$ are not arrow types or record types : $\pick \ b \in \mathbb{B}$. \\ 
%     $\texttt{if }b\texttt{ then }$
%     $\\\texttt{\ \ let gend = }\mkgen{\syntype_1}\texttt{ in }$
%     $\\ \texttt{\ \ if }\mkche{\syntype_2}{\texttt{gend}}\texttt{ then gend else } \mzero$
%     $\\ \texttt{else}$
%     $\\\texttt{\ \ let gend = }\mkgen{\syntype_2}\texttt{ in }$
%     $\\ \texttt{\ \ if }\mkche{\syntype_1}{\texttt{gend}}\texttt{ then gend else } \mzero$   
%     \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where $\syntype_1 = \mkfun{\syntype_{dom1}}{\syntype_{cod1}}, \syntype_2 = \mkfun{\syntype_{dom2}}{\syntype_{cod2}} : $ \\ $\mkfunv{\ev}{\\
%       \texttt{\ \ }\ife{\mkche{\syntype_{dom1}}{\ev}}{\mkgen{\syntype_{cod1}}}{\mkgen{\syntype_{cod2}}}
%     }$. 
%     \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where \\ 
%     $\syntype_1 = \{\hastype{\elbl_1}{\syntype_1'}, \cdots, \hastype{\elbl_n}{\syntype_n'}, \cdots, \hastype{\elbl_{11}}{\syntype_{11}'}, \cdots, \hastype{\elbl_{1m}}{\syntype_{1m}'}\}, 
%     \\ \syntype_2 = \{\hastype{\elbl_1}{\syntype_1''}, \cdots, \hastype{\elbl_n}{\syntype_n''}, \cdots, \hastype{\elbl_{21}}{\syntype_{21}''}, \cdots, \hastype{\elbl_{2n}}{\syntype_{2n}''}\} : $ \\ 
%     $\{\elbl_1 = \mkgen{\mkintersect{\syntype_1'}{\syntype_1''}}, \cdots, \elbl_n = \mkgen{\mkintersect{\syntype_n'}{\syntype_n''}}, \cdots, \elbl_{11} = \syntype_{11}, \cdots, \elbl_{2n} = \syntype_{2n}'\}$. 
%     \item $\mkgen{\mktset{\syntype}{p}} : $ \\ 
%     $\texttt{let gend = }\mkgen{\syntype} \texttt{ in } \ife{\texttt{(p gend)}}{\texttt{gend}}{\mzero}.$
%     \item $\mkgen{\mkdfun{\ev}{\syntype_1}{\syntype_2}} : $
%     \\$\mkfunv{\ev'}{\ife{\mkche{\tau_1}{\ev'}}{\mkgen{\substitute{\syntype_2}{\ev'}{\ev}}}{\eerror}}.$
%     \item $\mkgen{\mkmiu{\alpha}{\syntype}} : \mkgen{\substitute{\syntype}{\alpha}{\mkmiu{\alpha}{\syntype}}}.$
%     \item $\mkgen{\{\hastype{\elbl_1}{\syntype_1}, \cdots, \hastype{\elbl_n}{\syntype_n}\}} :$ \\ $\texttt{let }\eval_1 = \mkgen{\syntype_1}\texttt{ in }\cdots\texttt{ let }\eval_n = \mkgen{\syntype_n}\texttt{ in } \{\elbl_1 = \eval_1, \cdots, \elbl_n = \eval_n\}.$
%   \end{enumerate}
% \end{definition}

% \begin{definition}[Defining Checker in the extended language]
%   \label{def_cheExt}
%   % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
%   \ \par 
%   \begin{enumerate}
%     \item $\mkche{\tpoly_i}{\expr} : \matches{\expr}{\vpoly_i}$.
%     \item $\mkche{\mkunion{\syntype_1}{\syntype_2}}{\expr} : \mkche{\syntype_1}{\expr} \texttt{ or } \mkche{\syntype_2}{\expr}$.
%     \item $\mkche{\mkintersect{\syntype_1}{\syntype_2}}{\expr} : \mkche{\syntype_1}{\expr} \texttt{ and } \mkche{\syntype_2}{\expr}$. 
%     \item $\mkche{\mktset{\syntype}{p}}{\expr} : \mkche{\syntype}{\expr} \texttt{ and } \evaluate{\expr} = \gttrue$.
%     \item $\mkche{\mkdfun{\ev}{\syntype_1}{\syntype_2}}{\expr} : \texttt{let arg = } \mkgen{\syntype_1} \texttt{ in } \mkche{\substitute{\syntype_2}{\texttt{arg}}{\ev}}{\texttt{(e arg)}}$.
%     \item $\mkche{\mkmiu{\alpha}{\syntype}}{\expr} : \mkche{\substitute{\syntype}{\mkmiu{\alpha}{\syntype}}{\alpha}}{\expr}$.
%     \item $\mkche{\{\hastype{\elbl_1}{\syntype_1}, \cdots, \hastype{\elbl_m}{\syntype_m}\}}{\expr} :$
%     $\evaluate{\expr} = \{\elbl_1 = \eval_1, \cdots, \elbl_m = \eval_m, \cdots, \elbl_n = \eval_n\}^{\{\elbl_1, \cdots, \elbl_m\}}$ \\ 
%     $\texttt{and } \mkche{\syntype_1}{\eval_1} \cdots \texttt{ and } \mkche{\syntype_m}{\eval_m}$.
%   \end{enumerate}
% \end{definition}

\section{Selective typechecking}

We allow users to declare types in their program selectively. If an expression doesn't have a type declaration, we assume that the user does not wish for us to check its type. In other words, we will only be checking explicitly declared types in the user program.

% \begin{figure}[hbt!]%{r}{.5\textwidth}%
%   \begin{grammar}
%             \grule[expressions]{\expr}{
%                 \cdots
%                 \gor \letfunt
%                 \gor \letint{\ev}{\syntype}{\expr}{\expr}
%             }
%         \end{grammar}
%     \caption{Updated language grammar}
%     \label{fig_updatedGrammar}
% \end{figure}

% For presentation

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
                \cdots
                \gor \letfunt
                \gline
                \gor \letint{\ev}{\syntype}{\expr}{\expr}
            }
            \grule[types]{\syntype}{
              \cdots
              \gor \mktset{\syntype}{\expr}
              \gor \mkdfun{\ev}{\syntype}{\syntype}
            }
        \end{grammar}
    \caption{Updated language grammar}
    \label{fig_updatedGrammar}
\end{figure}

\begin{definition}[Defining Generator in the extended language]
  \label{def_genExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkgen{\mktset{\syntype}{p}} : $ \\ 
    $\texttt{let gend = }\mkgen{\syntype} \texttt{ in } \ife{\texttt{(p gend)}}{\texttt{gend}}{\mzero}.$
    \item $\mkgen{\mkdfun{\ev}{\syntype_1}{\syntype_2}} : $
    \\$\mkfunv{\ev'}{\ife{\mkche{\tau_1}{\ev'}}{\mkgen{\substitute{\syntype_2}{\ev'}{\ev}}}{\eerror}}.$
  \end{enumerate}
\end{definition}

\begin{definition}[Defining Checker in the extended language]
  \label{def_cheExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkche{\mktset{\syntype}{p}}{\expr} : $\\ 
    $\mkche{\syntype}{\expr} \texttt{ and } \evaluate{\expr} = \gttrue$.
    \item $\mkche{\mkdfun{\ev}{\syntype_1}{\syntype_2}}{\expr} :$\\ 
    $\texttt{let arg = } \mkgen{\syntype_1} \texttt{ in } \mkche{\substitute{\syntype_2}{\texttt{arg}}{\ev}}{\texttt{(e arg)}}$.
  \end{enumerate}
\end{definition}

\begin{definition}[Refinement type]
  $\ \models \hastype{\expr}{\mktset{\syntype}{p}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall \eval.$ if $\expr \smallsteps[] \eval$, 
  
  then $\ \models \hastype{\eval}{\syntype}$ and $p \ \eval \smallsteps[] \gttrue$.

  \begin{itemize}
    \item $\mkche{\mktset{\syntype}{p}}{\expr} : $\\ 
    $\letin{\_}{\mkche{\syntype}{\expr}}{\ife{(p \  e)}{e}{\eerror}}$
    \item $\mkgen{\mktset{\syntype}{p}} : $ \\ 
    $\texttt{let gend = }\mkgen{\syntype} \texttt{ in } \ife{\texttt{(p gend)}}{\texttt{gend}}{\mzero}$
  \end{itemize}
\end{definition}

\pagebreak

\begin{definition}[Dependent type]
  $\ \models \hastype{\expr}{\mkdfun{\ev}{\syntype_1}{\syntype_2}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall{\eval_f}$, if $\expr \smallsteps[] \eval_f$, 
  
  then $\forall \eval$, if $\models \hastype{\eval}{\syntype_1}$, then $\models \hastype{\eval_f\ \eval}{\substitute{\syntype_2}{\eval}{\ev}}$.

  \begin{itemize}
    \item $\mkche{\mkdfun{\ev}{\syntype_1}{\syntype_2}}{\expr} :$\\ 
    $\texttt{let arg = } \mkgen{\syntype_1} \texttt{ in } \mkche{\substitute{\syntype_2}{\texttt{arg}}{\ev}}{\texttt{(e arg)}}$
    \item $\mkgen{\mkdfun{\ev}{\syntype_1}{\syntype_2}} : $
    \\$\mkfunv{\ev'}{\letin{\_}{\mkche{\tau_1}{\ev'}}{\mkgen{\substitute{\syntype_2}{\ev'}{\ev}}}}$
  \end{itemize}
\end{definition}

